// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";
  var AbstractTCPSocket, exports, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  var exports = (_ref = window.net) != null ? _ref : window.net = {};

  /*
   * Abstract TCP socket.
   * Events emitted:
   * - 'connect': the connection succeeded, proceed.
   * - 'data': data received. Argument is the data (array of longs, atm)
   * - 'end': the other end sent a FIN packet, and won't accept any more data.
   * - 'error': an error occurred. The socket is pretty much hosed now. (TODO:
  #    investigate how node deals with errors. The docs say 'close' gets sent right
  #    after 'error', so they probably destroy the socket.)
  # - 'close': emitted when the socket is fully closed.
  # - 'drain': emitted when the write buffer becomes empty
  */


  AbstractTCPSocket = (function(_super) {

    __extends(AbstractTCPSocket, _super);

    function AbstractTCPSocket() {
      return AbstractTCPSocket.__super__.constructor.apply(this, arguments);
    }

    AbstractTCPSocket.prototype.connect = function(port, host) {};

    AbstractTCPSocket.prototype.write = function(data) {};

    AbstractTCPSocket.prototype.close = function() {};

    AbstractTCPSocket.prototype.setTimeout = function(ms, callback) {
      var _this = this;
      if (ms > 0) {
        this.timeout = setTimeout((function() {
          return _this.emit('timeout');
        }), ms);
        this.timeout_ms = ms;
        if (callback) {
          return this.once('timeout', callback);
        }
      } else if (ms === 0) {
        clearTimeout(this.timeout);
        if (callback) {
          this.removeListener('timeout', callback);
        }
        this.timeout = null;
        return this.timeout_ms = 0;
      }
    };

    AbstractTCPSocket.prototype._active = function() {
      var _this = this;
      if (this.timeout) {
        clearTimeout(this.timeout);
        return this.timeout = setTimeout((function() {
          return _this.emit('timeout');
        }), this.timeout_ms);
      }
    };

    return AbstractTCPSocket;

  })(EventEmitter);

  exports.AbstractTCPSocket = AbstractTCPSocket;

}).call(this);
