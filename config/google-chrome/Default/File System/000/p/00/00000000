
        /**
 Interface for component. Every component should be derived from this interface
 @constructor
 */
function ComponentInterface() {
    /** Create the component
     * @param {Object} config of the application
     */
    this.create = function(config) {};

    /** Clear any data the component may create */
    this.cleanup = function() {};

    /** Destroy component */
    this.destroy = function() {};

    /* Notify component about options
    * @param {Object} options to use*/
    this.options = function(options) {};
}


/**
 Application context. Manages components (registration, creation, destroy, clean). Can work as another component
 @param {String} name of the context
 @extents ComponentInterface
 @constructor
 */
function DCMContext(name) {
    ComponentInterface.call(this);
    var configuration = {};
    var componentsMap = {};
    var logDump = [];

    function getComponent(name) {
        var component = componentsMap[name];
        if (!component) {
            throw "Unknwown Component with name: "+name;
        }
        return component;
    }

    function checkCircularReference(component) {
        if (component.progress) {
            throw "Circular reference detected on element: "+component.name;
        }
        component.progress = true;
    }

    function executeCreate(component, initializedMap) {
        try {
            if (typeof component.loader == "function") {
                component.loader = new component.loader();
            }
            component.loader.create(configuration);
            initializedMap[component.name] = true;
        } catch (e) {
            throw "Error during component load: "+e;
        }
    }

    function createDependencies(component, initializedMap) {
        for (var i = 0; i < component.dependencies.length; i++) {
            var dependentComponent = getComponent(component.dependencies[i]);
            createComponent(dependentComponent, initializedMap);
        }
    }

    function createComponent(component, initializedMap) {
        if (initializedMap[component.name]) {
            return;
        }

        try {
            checkCircularReference(component);
            createDependencies(component, initializedMap);
            executeCreate(component, initializedMap);
        } catch (e) {
            throw e+"\nCannot load component: "+component.name;
        }

        component.progress = false;
    }

    function destroyChildren(component, destroyedMap) {
        var componentName = component.name;
        for (var childName in componentsMap) {
            var childComponent = getComponent(childName);
            if (childComponent.dependencies.indexOf(componentName) > -1 && !destroyedMap[componentName]) {
                destroyComponent(childComponent, destroyedMap);
            }
        }
    }

    function executeDestroy(component, destroyedMap) {
        try {
            component.loader.destroy();
        } catch (e) {
            //destruction errors. ignore
        }
        destroyedMap[component.name] = true;
    }

    function destroyComponent(component, destroyedMap) {
        if (destroyedMap[component.name]) {
            return;
        }

        destroyChildren(component, destroyedMap);
        executeDestroy(component, destroyedMap);
    }

    function cleanupUninitializedComponents(initializedMap) {
        for (var componentName in componentsMap) {
            if (!initializedMap[componentName]) {
                delete componentsMap[componentName];
            }
        }
    }

    /**
     Register component in application
     @param {String} name Unique name of current component
     @param {String[]} dependencies List of dependent components
     @param {ComponentInterface|Function} component Component object or constructor to create it.
     */
    this.addComponent = function(name, dependencies, component) {
        componentsMap[name] = {
            name: name,
            loader: component,
            dependencies: dependencies,
            progress: false
        }
    };

    function logStartupErrors(context) {
        if (logDump.length == 0) {
            return;
        }

        try {
            var logger = context.loggerFactory.getLogger("DCMContext");
            logger.error("Initialization errors:\n" + logDump.join("\n"));
        } catch (e) {
            //in case logging is broken anyway.
        }
        logDump = [];
    }

    /**
     Start Application
     @param {Object} config of the application
    */
    this.create = function(config) {
        configuration = config;
        var initializedMap = {};
        for (var name in componentsMap) {
            try {
                var component = getComponent(name);
                createComponent(component, initializedMap);
            } catch (e) {
                logDump.push(e.toString());
                //cannot initialize some component. good place for logging;
            }
        }
        cleanupUninitializedComponents(initializedMap);
        logStartupErrors(this);
    };

    /** Stop application*/
    this.destroy = function() {
        var destroyedMap = {};
        for (var name in componentsMap) {
            try {
                var component = getComponent(name);
                destroyComponent(component, destroyedMap);
            } catch (e) {
                //cannot destroy some component. ignore
            }
        }
    };

    /** Clean any data crated by components (Uninstall)*/
    this.cleanup = function() {
        for (var name in componentsMap) {
            try {
                var component = getComponent(name);
                component.loader.cleanup();
            } catch (e) {
                //error during data cleanup. good place for logging;
            }
        }
    };

    /** Notify components about new external options*/
    this.options = function(options) {
        for (var name in componentsMap) {
            try {
                var component = getComponent(name);
                component.loader.options(options);
            } catch (e) {
                //error during calling options. ignore
            }
        }
    };

    /** Return context name
     * @return String*/
    this.getName = function() {
        return name;
    }
}


/** Interface of the browser for DCM to interact with it.
 * @constructor */
function BrowserInterface() {
    // TODO: change the description below
    /** Returns if privacy mode is currently enabled. Use messages to get state changes.
     * @param {Function(ignoreAll, tabs)} callback to notify about results
     * @param {Boolean} callback.ignoreAll Indicates whether the data from all tabs should be discarded
     * @param {Array} callback.tabs The array of tab ids for which privacy mode is enabled.
     * Do not use when callback.ignoreAll is true */
    this.isPrivacyModeEnabled = function(callback) {
        throw "Method is not implemented";
    };

    /** Open Custom modal dialog in browser
     * @param {Object} config of the dialog
     * @param {String} config.title of the dialog
     * @param {String} config.text to display on dialog
     * @param {String} config.accept name of accept button
     * @param {String} config.reject name of reject button
     * @param {Function} [callback] The callback to be called when user closes dialog
     * @return {Boolean} If user accepted or discarded dialog question
     * */
    this.openDialog = function(config, callback) {
        return false;
    };

    this.openUrl = function(url) {
        throw "Method is not implemented";
    }
}

/** Interface of the Remote {@link BrowserInterface}
 * @extends BrowserInterface
 * @constructor*/
function RemoteBrowserInterface() {
    BrowserInterface.call(this);
    RemoteObjectSpec.call(this, {
        name: MESSAGING_DATA.REMOTE_BROWSER_COMPONENT,
        quietMethods: ["openUrl"],
        responseMethods: ["isPrivacyModeEnabled", "openDialog"]
    })
}

/** Communication Component which initialize communication mechanism in your context
 * @param {DCMContext} context of application
 * @constructor */
function CommunicationComponent(context) {
    ComponentInterface.call(this);

    this.create = function(config) {
        /** Communication related instances
         * @memberOf dcm
         * @memberOf engine */
        context.communication = {};

        /** Instance of client communication controller. Do not use it directly
         * @memberOf dcm
         * @type CommunicationController */
        context.communication.controller = new CommunicationController(context);
        context.communication.factory = new CommunicationFactory(context);
        context.communication.remote = new RemoteCallsController(context);
    }
}


/** Main class for sending/receiving messages.
 * @extends CommunicationControllerInterface
 * @constructor */
function CommunicationController() {
    CommunicationControllerInterface.call(this);
    ReceieversHandlerMixin.call(this);
    var transmitter;

    function notifyTransmitter(subject, topic, data) {
        if (transmitter) {
            var serialized = serializeData(data);
            transmitter.receive(subject, topic, serialized)
        }
    }

    function parseData(data) {
        return JSON.parse(data);
    }

    function serializeData(data) {
        if (data === undefined || data === null) {
            return JSON.stringify(null)
        } else if (data && data.getJson) {
            return data.getJson();
        } else {
            return JSON.stringify(data);
        }
    }

    this.send = function(subject, topic, data) {
        this.notifyReceivers(subject, topic, data);
    };

    this.transmit = function(subject, topic, data) {
        notifyTransmitter(subject, topic, data);
    };

    this.receive = function(subject, topic, data) {
        var parsed = parseData(data);
        this.notifyReceivers(subject, topic, parsed);
    };

    this.setTransmitter = function(theTransmitter) {
        transmitter = theTransmitter;
    };
}


/** Interface of the communication object
 * @constructor */
function CommunicationControllerInterface() {
    /** Send message to receivers
     * @param {String} subject of the message
     * @param {String} topic of the message
     * @param {Object|MessageData} data of the message*/
    this.send = function(subject, topic, data) {};

    /** Receive message from another communication controller
     * @param {String} subject of the message
     * @param {String} topic of the message
     * @param {String} data of the message*/
    this.receive = function(subject, topic, data) {};

    /** Transmit message to another context
     * @param {String} subject of the message
     * @param {String} topic of the message
     * @param {Object|MessageData} data of the message*/
    this.transmit = function(subject, topic, data) {};

    /** Set transmitter which will be transferring messages to another communication controller
     * @param {CommunicationControllerInterface} theTransmitter */
    this.setTransmitter = function(theTransmitter) {};

    /** Add messages receiver
     * @param {String} subject of the message to receive
     * @param {Function} receiver function*/
    this.addReceiver = function(subject, receiver) {};

    /** Remove messages receiver
     * @param {String} subject of the message to receive
     * @param {Function} receiver function*/
    this.removeReceiver = function(subject, receiver) {};
}

/** Communication classes factory. Used to create messages sender/recievers.
 * Instance can be found in {@link dcm.communicatino.factory} or {@link engine.communication.factory}
 * @param {DCMContext} context of the application where classes should be created
 * @constructor */
function CommunicationFactory(context) {
    /** Create instance of {@link MessageRecieverMixin}
     @param {String} subject component/class specific name for which messages should be accepted
     @param {String} [topic='.*'] regexp pattern or specifc message type that should be accepted. Accepts all messages from this component if ommited
     @return {MessageRecieverMixin}
     */
     this.createReciever = function(subject, topic) {
        return new MessageRecieverMixin(context, subject, topic);
    };

    /** Extend your class with methods of {@link MessageRecieverMixin}
     @param {Object} self pointer to class which should be extended
     @param {String} subject component/class specific name for which messages should be accepted
     @param {String} [topic='.*'] regexp pattern or specifc message type that should be accepted. Accepts all messages from this component if ommited
     */
    this.extendReciever = function(self, subject, topic) {
        MessageRecieverMixin.call(self, context, subject, topic);
    };

    /** Create instance of {@link MessageSenderMixin}
     @return {MessageSenderMixin}
     */
    this.createSender = function() {
        return new MessageSenderMixin(context);
    };

    /** Extend your class with methods of {@link MessageSenderMixin}
     * @param {Object} self pointer to class which should be extended
     * */
    this.extendSender = function(self) {
        MessageSenderMixin.call(self, context);
    };
  }

/** Debugging class which listen to messages and shows them using alerts
 * @param subject message name
 * @param [topic] message type
 * @class*/
function DebugMessageReceiver(subject, topic) {
    MessageRecieverMixin.call(this, subject, topic);

    this.onMessage = function(topic, data) {
        alert("subject: " + subject + "\ntopic:  " + topic + "\ndata:   " + data);
    }
}

/** Message data object. Allow to has custom serialize procedures.
 * @constructor */
function MessageData() {
    /** Override this method to return plain object that can be transmitted
     * @return {Object} */
    this.getJson = function() {
        return {};
    }
}

/**
 Allows to listen for messages sent by other components or client code. Can be used as mixin or standalone class.
 Avoid direct usage. Use context.communication.factory to create.
 @param {DCMContext} context dcm or engine context. Depends on location of user
 @param {String} subject component/class specific name for which messages should be accepted
 @param {String} [topic='.*'] regexp pattern or specifc message type that should be accepted. Accepts all messages from this component if ommited
 @constructor
 */
function MessageRecieverMixin(context, subject, topic) {
    var self = this;
    var acceptedTopic = new RegExp(topic ? topic : MESSAGING_DATA.ANY_TOPIC);

    function receiverFunction(topic, data) {
        if (acceptedTopic.test(topic)) {
            self.onMessage(topic, data);
        }
    }

    context.communication.controller.addReceiver(subject, receiverFunction);

    /** Execute to stop listening for the messages. */
    this.unregister = function() {
        context.communication.controller.removeReceiver(subject, receiverFunction)
    };

    /**
    * Override this method to recieve messages specified in the constructor subject/topic parameters
    * @param {String} topic type of recieved message
    * @param data data send by the component. */
    this.onMessage = function(topic, data) {};
}

/** Allows to send messages that can be recieved by {@link MessageRecieverMixin}
 * @constructor
 * */
function MessageSenderMixin(context) {

    function checkParameters(subject, topic) {
        if (!subject || !topic) {
            throw "Incorrect message parameters";
        }
    }

    /** Send required messages
     * @param {String} subject message name
     * @param {String} topic message type
     * @param [data=undefined] message data*/
    this.send = function(subject, topic, data) {
        checkParameters(subject, topic);
        context.communication.controller.send(subject, topic, data);
    };

    /** Transmit required messages to another context
     * @param {String} subject message name
     * @param {String} topic message type
     * @param {Object} data of the message. Should be JSON serializable*/
    this.transmit = function(subject, topic, data) {
        checkParameters(subject, topic);
        context.communication.controller.transmit(subject, topic, data);
    }
}

/** List of subject/topics which used in the client/engine communication.*/
var MESSAGING_DATA = {
    ANY_TOPIC : ".*",

    APPLICATION_LOG_SUBJECT : "application-log",

    REQUEST_MONITORING_SUBJECT : "monitoring-requests",
    REQUEST_MONITORING_DATA_READY : "request-data-availabale",

    PRIVACY_MODE_SUBJECT : "privacy-mode",
    PRIVACY_MODE_ENABLED : "entering-privacy-mode",
    PRIVACY_MODE_DISABLED : "exiting-privacy-mode",

    XHR_REMOTE_FUNCTION_SUBJECT : "xhr-executor-remote-function",
    REMOTE_DISK_STORAGE : "remote-disk-storage",
    REMOTE_SETTINGS_STORAGE : "remote-settings-storage",
    REMOTE_BROWSER_COMPONENT : "remote-browser-component",

    REMOTE_OBJECT_SUBJECT : "remote-objects",
    REMOTE_OBJECT_CREATE_TOPIC : "create-object",
    REMOTE_OBJECT_DESROY_TOPIC : "destroy-object",

    ENGINE_WORKER_SUBJECT : "engine-worker",
    WORKER_ERROR_TOPIC : "worker-code-error",
    WORKER_CODE_EXIST_TOPIC : "worker-class-ready",

    ENGINE_CREATE_TOPIC : "engine-create-command",
    ENGINE_CREATED_TOPIC : "engine-created-command",
    ENGINE_DESTROY_TOPIC : "engine-destroy-command",
    ENGINE_OPTIONS_TOPIC : "engine-options-command",
    ENGINE_CLEANUP_TOPIC : "engine-cleanup-command",

    SYSTEM_INFO_SUBJECT : "system_info_subject",
    LOCAL_IP_ADDRESS_DETECTED_TOPIC : "local_ip_address_detected_topic",

    OPT_IN_DIALOG_SUBJECT : "opt_in_dialog_subject",
    OPT_IN_DIALOG_CONFIG_AVAILABLE : "opt_in_dialog_config_available",
    OPT_IN_DIALOG_CONFIG_REMOVED : "opt_in_dialog_config_removed"
};


function ReceieversHandlerMixin() {
    var allReceivers = {};

    function getReceivers(subject) {
        if (!allReceivers[subject]) {
            allReceivers[subject] = [];
        }
        return allReceivers[subject];
    }


    this.addReceiver = function(subject, receiver) {
        var receivers = getReceivers(subject);
        receivers.push(receiver);
    };

    this.removeReceiver = function(subject, receiver) {
        var receivers = getReceivers(subject);
        var index = receivers.indexOf(receiver);
        if (index > -1) {
            receivers.splice(index, 1);
        }
    };

    this.notifyReceivers = function(subject, topic, data) {
        var receivers = getReceivers(subject);
        for (var i = 0; i < receivers.length; i++) {
            try {
                receivers[i](topic, data);
            } catch (e) {
                //ignore notifications errors for now
            }
        }
    }

}

/** Controller of remote calls for DCM registers Remote Objects. Create Remote Functions.
 * Use aleady created instance from {@link dcm.controller.remote} or {@link engine.controller.remote}
 * @param {DCMContext} context of the current controller
 * @constructor */
function RemoteCallsController(context) {
    var factory = new RemoteObjectsFactory(context);


    /** Register class as target for Remote Object calls
     * @param {Function} interfaceConstructor of Remote Object which has {@link RemoteObjectSpec}
     * @param {Function} targetConstructor constructor of Remote Object which extends interface and {@link RemoteObjectTarget}*/
    this.registerRemoteTarget = function(interfaceConstructor, targetConstructor) {
        factory.registerRemoteObject(interfaceConstructor, targetConstructor);
    };

    /** Create instance of {@link RemoteFunctionTarget} to process remote calls
     * @param {String} name of the remote function
     * @param {Function} callback to process remote calls
     * @return RemoteFunctionTarget*/
    this.createRemoteFunctionTarget = function(name, callback) {
        return new RemoteFunctionTarget(context, name, callback);
    };

    /** Create instance of {@link RemoteFunctionSource} to execute remote calls
     * @param {String} name of the remote function
     * @return RemoteFunctionSource */
    this.createRemoteFunctionSource = function(name) {
        return new RemoteFunctionSource(context, name)
    };

    /** Create instance of {@link RemoteFunctionQuietTarget} to process quiet remote calls
     * @param {String} name of the remote function
     * @param {Function} callback to process remote calls
     * @return RemoteFunctionQuietTarget*/
    this.createQuietRemoteFunctionTarget = function(name, callback) {
        return new RemoteFunctionQuietTarget(context, name, callback);
    };

    /** Create instance of {@link RemoteFunctionQuietSource} to execute one way remote calls
     * @param {String} name of the remote function
     * @return RemoteFunctionQuietSource */
    this.createQuietRemoteFunctionSource = function(name) {
        return new RemoteFunctionQuietSource(context, name)
    };

    /** Extend current Object with Remote Object Source functionality
     * @param {Object} self current class
     * @param {Array} args of the constructor*/
    this.extendRemoteObjectSource = function(self, args) {
        RemoteObjectSource.call(self, context, args);
    };

    /** Extend current Object with Remote Object Target functionality
     * @param {Object} self current class
     * @param {Object?} target of calls. leave blank to use self as target
     * */
    this.extendRemoteObjectTarget = function(self, target) {
        target = target ? target : self;
        RemoteObjectTarget.call(self, context, target);
    };
 }

/** Remote Function source which doesn't expect any response
 * @extend FunctionMessagesSender
 * @constructor*/
function RemoteFunctionQuietSource(context, name) {
    RemoteFunctionSource.call(this, context, name);

    var parentCall = this.callRemote;

    this.callRemote = function(data) {
        var args = this.convertArguments(arguments, 0);
        args.unshift(function() {});
        parentCall.apply(this, args);
    }
}

/** Remote Function quiet Target which doesn't provide any feedback
 * @extends RemoteFunctionTarget
 * @constructor */
function RemoteFunctionQuietTarget(context, name, method) {
    RemoteFunctionTarget.call(this, context, name, quietCallback);
    var self = this;

    function quietCallback(callback) {
        var args = self.convertArguments(arguments, 1);
        method.apply(method, args);
        callback(true);
    }
}

/** Performs Remote Function calls by name. Do not create manually use {@link CommunicationFactory}
 * @param {DCMContext} context current context
 * @param {String} name of the remote function
 * @extends MessageRecieverMixin
 * @extends RemoteUtils
 * @constructor*/
function RemoteFunctionSource(context, name) {
    RemoteUtils.call(this);
    context.communication.factory.extendReciever(this, name+"-response");

    var callerId = this.generateId();
    var callCount = 0;
    var callbacks = {};
    var sender = context.communication.factory.createSender();

    function getCallId() {
        callCount++;
        return callerId+"."+callCount;
    }

    /** Perform call to Remote Function
     * @param {Function} callback to receive results
     * @param {Object} data to send in remote function*/
    this.callRemote = function(callback, data) {
        var args = this.convertArguments(arguments, 1);
        var callId = getCallId();
        callbacks[callId] = callback;
        sender.transmit(name+"-call", callId, args);
    };

    this.onMessage = function responseArrived(topic, data) {
        data = data.slice();
        var callback = callbacks[topic];
        callback.apply(callback, data);
        delete callbacks[topic];
    };
}

/** Receives remote calls by name and forwards execution to the method. Do not create manually use {@link CommunicationFactory}
 * @param {DCMContext} context current context
 * @param {String} name of Remote function
 * @param {Function} method to process remote calls
 * @extends MessageRecieverMixin
 * @extends RemoteUtils
 * @constructor */
function RemoteFunctionTarget(context, name, method) {
    RemoteUtils.call(this);

    var self = this;
    var sender = context.communication.factory.createSender();
    context.communication.factory.extendReciever(this, name+"-call");

    function generateResponseCallback(topic) {
        return function() {
            var args = self.convertArguments(arguments, 0);
            sender.transmit(name+"-response", topic, args);
        }
    }

    this.onMessage = function(topic, data) {
        data = data.slice();
        data.unshift(generateResponseCallback(topic));
        method.apply(method, data);
    }
}

/** Handles construction of Remote objects. Contain list of registered Remote Objects
 * @constructor */
function RemoteObjectsFactory(context) {
    context.communication.factory.extendReciever(this, MESSAGING_DATA.REMOTE_OBJECT_SUBJECT);

    var logger = context.loggerFactory.getLogger("communication.RemoteObjectsFactory");

    var remoteObjects = {};
    var remoteConstructors = {};

    function construct(constructor, args) {
        function F() {
            return constructor.apply(this, args);
        }
        F.prototype = constructor.prototype;
        return new F();
    }

    function constructObject(data) {
        logger.debug("Constructing remote target: "+data.interfaceName);
        var objectConstructor = remoteConstructors[data.interfaceName];
        if (objectConstructor) {
            try {
                var args = data.constructorArguments;
                args.unshift(context);
                var instance = construct(objectConstructor, args);
                var instanceId = data.instancesId;
                instance.initRemoteTarget(instanceId);
                remoteObjects[instanceId] = instance;
                logger.debug("Remote target constructed.");
            } catch (e) {
                logger.error("Cannot construct remote target: "+e);
            }
        } else {
            logger.debug("Remote target is not registered.")
        }
    }

    function destroyObject(instanceId) {
        var object = remoteObjects[instanceId];
        if (object) {
            logger.debug("Destroying remote target: "+instanceId);
            delete remoteObjects[instanceId];
            object.destroy();
        } else {
            logger.debug("Cannot destroy remote target. Instance not found: "+instanceId);
        }
    }

    this.onMessage = function(topic, data) {
        if (topic == MESSAGING_DATA.REMOTE_OBJECT_CREATE_TOPIC) {
            constructObject(data);
        } else if (topic == MESSAGING_DATA.REMOTE_OBJECT_DESROY_TOPIC) {
            destroyObject(data);
        }
    };

    this.registerRemoteObject = function(interfaceConstructor, targetConstructor) {
        var interfaceInstance = new interfaceConstructor();
        logger.info("Registering remote target: "+interfaceInstance.getRemoteName());
        remoteConstructors[interfaceInstance.getRemoteName()] = targetConstructor;
    }
}

/** Extend this object to receive functionality of Remote Object source.
 * Your object should extend {@link RemoteObjectSpec}.
 * As result if you will call methods specified in specification target will be called automatically.
 * Do not create manually use {@link RemoteCallsController}
 * @param {DCMContext} context of your applicaiton
 * @param {Arguments} constructorArguments passed during creation of your object.
 * @constructor*/
function RemoteObjectSource(context, constructorArguments) {
    var self = this;
    var remoteFunctions = [];
    var sender = context.communication.factory.createSender();

    createResponseMethods(this.getResponseMethods(), "createRemoteFunctionSource");
    createResponseMethods(this.getQuietMethods(), "createQuietRemoteFunctionSource");
    createRemoteObject();

    function createRemoteObject() {
        var args = self.convertArguments(constructorArguments, 0);
        sender.transmit(MESSAGING_DATA.REMOTE_OBJECT_SUBJECT, MESSAGING_DATA.REMOTE_OBJECT_CREATE_TOPIC, {
            interfaceName: self.getRemoteName(),
            instancesId: self.getInstanceId(),
            constructorArguments: args})
    }

    function createResponseMethods(methodNames, constructionName) {
        for (var i = 0; i < methodNames.length; i++) {
            var methodName = methodNames[i];
            var methodId = self.constructMethodId(methodName);
            var func = context.communication.remote[constructionName](methodId);
            remoteFunctions.push(func);
            createMethod(methodName, func);
        }
    }

    function createMethod(name, remoteFunction) {
        self[name] = function() {
            var args = self.convertArguments(arguments, 0);
            remoteFunction.callRemote.apply(remoteFunction, args);
        }
    }

    this.destroy = function() {
        sender.transmit(MESSAGING_DATA.REMOTE_OBJECT_SUBJECT, MESSAGING_DATA.REMOTE_OBJECT_DESROY_TOPIC, self.getInstanceId());
        for (var i = 0; i < remoteFunctions.length; i++) {
            remoteFunctions[i].unregister();
        }
    }
}

/** Specification of Object which can be instantiated and interacted remotely
 *  Interfaces should extend this Class to allow Remote Functions call between instances.
 * @param {Object} specJson of this object
 * @param {String} specJson.name unique name of Object class.
 * @param {Array} specJson.quietMethods method names which doesn't provide any response
 * @param {Array} specJson.responseMethods method names which provide response
 * @extend RemoteUtils
 * @constructor
 * */
function RemoteObjectSpec(specJson) {
    RemoteUtils.call(this);
    var instanceId = specJson.name+"-"+this.generateId();

    /** Get unique name of Remote Object class
     * @return {String}*/
    this.getRemoteName = function() {
        return specJson.name;
    };

    /** Get Unique id for new instance
     * @return {String}*/
    this.getInstanceId = function() {
        return instanceId;
    };

    /** Set instance id on target side*/
    this.setInstanceId = function(id) {
        instanceId = id;
    };

    /** Get list of messages wich doesn't produce response
     * @return {String[]}*/
    this.getQuietMethods = function() {
        return specJson.quietMethods;
    };

    /** Get list of methods which provide response
     * @return {String[]}*/
    this.getResponseMethods = function() {
        return specJson.responseMethods;
    };

    /** Construct unique method name
     * @param {String} methodName to construct
     * @return {String}*/
    this.constructMethodId = function(methodName) {
        return instanceId+"-"+methodName;
    }
  }

/** Extend this object to receive functionality of Remote Object target.
 * Your object should extend {@link RemoteObjectSpec}.
 * Constructor of your object should be registered in {@link RemoteCallsController}
 * As result methods specified in specification will be called when remote source calling methods.
 * Do not create manually use {@link RemoteCallsController}
 * @param {DCMContext} context of your applicaiton
 * @param {Object} target where methods should be called. Use this for own methods.
 * @constructor*/
function RemoteObjectTarget(context, target) {
    var self = this;
    var remoteFunctions = [];

    function createMethodConnectors(methodsNames, constructionName) {
        for (var i = 0; i < methodsNames.length; i++) {
            var methodName = methodsNames[i];
            var methodId = self.constructMethodId(methodName);
            var func = context.communication.remote[constructionName](methodId, createConnector(methodName));
            remoteFunctions.push(func);
        }
    }

    function createConnector(name) {
        return function() {
            var args = self.convertArguments(arguments, 0);
            target[name].apply(self, args);
        }
    }

    /** Init target with instance id identical to the source. This allow one to one communication.
     * Called automatically for registered Objects.
     * @param {String} instanceId of current target*/
    this.initRemoteTarget = function(instanceId) {
        this.setInstanceId(instanceId);
        createMethodConnectors(this.getResponseMethods(), "createRemoteFunctionTarget");
        createMethodConnectors(this.getQuietMethods(), "createQuietRemoteFunctionTarget");
    };

    this.destroy = function() {
        for (var i = 0; i < remoteFunctions.length; i++) {
            remoteFunctions[i].unregister();
        }
    }
}

/** Remote calls utils. Contain use-full methods to work with Remote classes
 * @constructor */
function RemoteUtils() {
    /** Retrieve array of arguments from Arguments object starting at specific position
     * @param {Arguments|Array} args from which to retrieve
     * @param {Number} start of the first argument
     * @return {Array} of arguments */
    this.convertArguments = function(args, start) {
        return Array.prototype.splice.call(args, start);
    };

    /** Generate unique id based on current timestamp and random number*/
    this.generateId = function() {
        return Date.now()+"-"+Math.floor(Math.random() * 10000)
    }
}


/** Perform communication with WebWorker.
 * @param {Worker} worker to decorate.
 * @extends CommunicationControllerInterface
 * @constructor*/
function WorkerCommunicator(worker) {
    CommunicationControllerInterface.call(this);
    ReceieversHandlerMixin.call(this);
    var self = this;
    var transmitter;

    function messageListener(event) {
        var messageData = event;
        if (!event.subject) {
            messageData = event.data;
        }

        self.notifyReceivers(messageData.subject, messageData.topic, messageData.data);

        if (transmitter) {
            transmitter.receive(messageData.subject, messageData.topic, messageData.data);
        }
    }

    function errorListener(event) {
        var message = '"'+event.message + ". At line: " + event.lineno+'"';
        self.notifyReceivers(MESSAGING_DATA.ENGINE_WORKER_SUBJECT, MESSAGING_DATA.WORKER_ERROR_TOPIC, message);

        if (transmitter) {
            transmitter.receive(MESSAGING_DATA.ENGINE_WORKER_SUBJECT,
                MESSAGING_DATA.WORKER_ERROR_TOPIC, message);
        }
    }

    function setListeners(onMessage, onError) {
        if(worker.on) {
            worker.on("message", onMessage);
        } else {
            worker.onmessage = onMessage;
        }

        if(worker.on) {
            worker.on("error", onError)
        } else {
            worker.onerror = onError;
        }
    }

    this.start = function() {
        setListeners(messageListener, errorListener);
    };

    this.stop = function() {
        setListeners(function(){}, function(){});
    };

    this.receive = function(subject, topic, data) {
        this.notifyReceivers(subject, topic, data);
        worker.postMessage({
            subject: subject,
            topic: topic,
            data: data
        });
    };

    this.setTransmitter = function(theTransmitter) {
        transmitter = theTransmitter;
    }
}

/** Interface of the Logger Factory.
 * @constructor */
function LoggerFactoryInterface() {

    /** Get instance of logger for your class
     * @param {String} className of the class that will be performing logging operations
     * @return {LoggerInterface} */
     this.getLogger = function(className) {
        return new LoggerInterface()
    };

    /**
     * Add appender to logger factory
     * @param appender */
    this.addAppender = function(appender) {
        throw "Method is not implemented";
    };

    /** Clear the logged data.
     * In case the log is a file, the file should be removed */
    this.clear = function() { }
}

/** Data Logger interface. Actual implementation accordinly to settings will be writing log entries to some log file
 * @constructor*/
function LoggerInterface() {
    /** Logs debug message
     * @param {string} message*/
    this.debug = function(message) {};
    /** Logs info message
     * @param {string} message*/
    this.info = function(message) {};
    /** Logs warn message
     * @param {string} message*/
    this.warn = function(message) {};
    /** Logs error message
     * @param {string} message*/
    this.error = function(message) {};
}


/** Holder of the request data that represents click stream
 * @param {Object} [jsonData] The JSON object that is used for request data initializing
 * @constructor */
function RequestData(jsonData) {
    var data = jsonData instanceof Object ? jsonData : {};

    if (!data.timestamp) {
        data.timestamp = Date.now();
    }

    this.setUrl = function(url) {
        data.url = url;
    };

    this.getUrl = function() {
        return data.url;
    };

    this.setTabId = function(tabId) {
        data.tabId = tabId;
    };

    this.getTabId = function() {
        return data.tabId;
    };

    this.setMethod = function(theMethod) {
        data.method = theMethod;
    };

    this.getMethod = function() {
        return data.method;
    };

    this.getTimestamp = function() {
        return data.timestamp;
    };

    this.setTimestamp = function(timestamp) {
        data.timestamp = timestamp;
    };

    this.setRequestType = function(requestType) {
        data.requestType = requestType;
    };

    this.getRequestType = function() {
        return data.requestType;
    };

    this.setPostData = function(postData) {
        data.postData = postData;
    };

    this.getPostData = function() {
        return data.postData;
    };

    this.setStatusCode = function(statusCode) {
        data.status = statusCode;
    };

    this.getStatusCode = function() {
        return data.status;
    };

    this.setFrameId = function(frameId) {
        data.frameId = frameId;
    };

    this.getFrameId = function() {
        return data.frameId;
    };

    this.setOpenerTabId = function(refId) {
        data.openerTabId = refId;
    };

    this.getOpenerTabId = function() {
        return data.openerTabId;
    };

    this.setRequestHeaders = function(headers) {
        data.requestHeaders = headers;
    };

    this.getRequestHeaders = function() {
        return data.requestHeaders;
    };

    this.setResponseHeaders = function(headers) {
        data.responseHeaders = headers;
    };

    this.getResponseHeaders = function() {
        return data.responseHeaders;
    };

    /** Get all data in JSON object
     * @return {Object} json object */
    this.getData = function() {
        return data;
    };
}

/** Remote Settings Interface. Defines remote methods.
 * @extends SettingsInterface
 * @extends RemoteObjectSpec
 * @constructor */
function RemoteSettingsInterface() {
    SettingsInterface.call(this);
    RemoteObjectSpec.call(this, {
        name: MESSAGING_DATA.REMOTE_SETTINGS_STORAGE,
        quietMethods: ["set", "remove", "removeAll"],
        responseMethods: []
    })
}


/** Remote Storage Interface. Defines remote methods.
 * @extends StorageInterface
 * @extends RemoteObjectSpec
 * @constructor */
function RemoteStorageInterface() {
    StorageInterface.call(this);
    RemoteObjectSpec.call(this, {
        name: MESSAGING_DATA.REMOTE_DISK_STORAGE,
        quietMethods: [],
        responseMethods: ["read", "write", "exist", "remove"]
    })
}


/** List of commonly used settings across engine.
 * Must contain only settings that should be available in both client and engine.
 * DO NOT add new settings that is accessible only from one context */
var SETTINGS = {
    CLIENT_VERSION: "version.client",
    ENGINE_VERSION: "version.engine",
    USER_ID: "user-id",
    GROUP_ID: "group-id",

    DCM_CONFIG_NAME: "DCM Config",
    DCM_CONFIG_VERSION: "DCM Config.version",

    CLIENT_VERSION_HEADER: "X-Client-Version",
    ENGINE_VERSION_HEADER: "X-Engine-Version",
    USER_ID_HEADER: "X-User-Id",
    GROUP_ID_HEADER: "X-Group-Id",
    DCM_CONFIG_VERSION_HEADER: "X-Dcm-Config",

    DATA_DISABLED_KEY: "data-capturing-disabled",
    EPOCH_OFFSET: "epoch-offset",

    LOCAL_ADDRESS: "local-address",
    CONFIRMATION_PAGE_SHOWN: "confirmation-page-shown",

    DIAGNOSTIC_URL: "https://collector.dataferb.com/diagnostic"
};

/** Operates with permanent toolbar settings
 * @constructor */
function SettingsInterface() {
    /** Set setting value
     * @param {string} key name of the setting
     * @param {(string|number|boolean)} value of the setting*/
    this.set = function(key, value) {};

    /** Get setting value
     * @param {string} key name of the setting
     * @return {(string|number|boolean|undefined)}*/
    this.get = function(key) {};

    /** Check if setting exists
     * @param {string} key name of the setting
     * @return {boolean}
     */
    this.has = function(key) {};

    /** Remove specified setting
     * @param {string} key name of the setting
     * */
    this.remove = function(key) {};

    /** <b>Remove all settings</b> for toolbar. <b>Important:</b> Do not use this mmethod in regular code*/
    this.removeAll = function() {};

    /** Get all settings
     * @return {Object} ket/value mapped object */
    this.getAll = function() {};
}


/**Manages access to FileStorage and Settings
 * @param {String} settingsRoot being used to distinguish between DCM settings and others toolbar
 * @constructor */
function StorageFactoryInterface(settingsRoot) {

    /** Creates File Storage that provides access to the File System
     * @param {String} name of the file
     * @return {StorageInterface} */
    this.getStorage = function(name) {};

    /** Creates Settings Storage that provides access to the toolbar's related preferences
     * @return {SettingsInterface} */
    this.getSettings = function() {}
}

/** Permanent Large volume Storage interface
 * @constructor */
function StorageInterface() {
    /** Read saved data
     * @param {Function} callback to be called when data available */
    this.read = function(callback) {};

    /** Write saved data
     * @param {Function} callback to be called when data saved with status
     * @param {String} value to save in storage*/
    this.write = function(callback, value) {};

    /** Writes data to the end of existing storage
     * @param {Function} callback to be called with writing status when data saved
     * @param {String} value to save */
    this.append = function(callback, value) {};

    /** Check if data available
     * @param {Function} callback to be called when data saved. */
    this.exist = function(callback) {};

    /** Remove stored data
     * @param {Function} callback to be called when data is removed*/
    this.remove = function(callback) {};
}


/** Tracks interval download interval for  specific config
 * @param {SettingsInterface} settings
 * @param {String} settingName
 * @param {Number} downloadInterval Interval in milliseconds
 * @constructor */
function IntervalChecker(settings, settingName, downloadInterval) {
    var callback;
    var timeoutId;

    function getLastCheckTime() {
        var dateString = settings.get(settingName);
        try {
            return parseInt(dateString, 10);
        } catch (e) {
            return 0
        }
    }

    function setLastCheckTime() {
        var dateString = Date.now().toString();
        settings.set(settingName, dateString);
    }

    function getNextInterval() {
        var lastTime = getLastCheckTime();
        if (lastTime > 0) {
            var timeSinceLastCheck = Math.abs(Date.now() - lastTime);
            if (timeSinceLastCheck < downloadInterval) {
                return downloadInterval - timeSinceLastCheck;
            }
        }

        return 0;
    }

    function scheduleNextCheck(interval) {
        timeoutId = setTimeout(notify, interval);
    }

    function clearNextCheck() {
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
    }

    function notify() {
        timeoutId = null;
        setLastCheckTime();
        scheduleNextCheck(downloadInterval);
        callback();
    }

    /** Start interval checker
     * @param {Function} theCallback function that will be called when next interval has come */
    this.start = function(theCallback) {
        callback = theCallback;

        scheduleNextCheck(getNextInterval());
    };

    /** Stop interval checks */
    this.stop = function() {
        callback = null;
        clearNextCheck();
    };

    /**
     * Updates last download time value
     */
    this.update = function() {
        if (callback) {
            throw "Update method should be called before start";
        }

        setLastCheckTime();
    };

    /** Returns interval status. True - no need to call callback.
     * False - should call callback
     * @return {boolean} */
    this.isUpToDate = function() {
        return getNextInterval() > 0;
    }
}


/**  Wrapper for URL specific functionality
 * @param {String} theUrl
 * @constructor */
function Url(theUrl) {
    var utils = new UrlUtils();
    var urlParts = utils.parseUrl(theUrl);
    var urlParams = utils.splitParams(urlParts.query);

    /** Returns array of query parameters
     * @return {Object} in key:value format */
    this.getParams = function() {
        return urlParams;
    };

    /** Set the query string for URL
     * @param {Object} params */
    this.setParams = function(params) {
        urlParams = params;
    };

    /** Return string representation of URL
     * @return {String} */
    this.toString = function() {
        var params = utils.joinParams(urlParams);

        if (urlParts.query.length > 0) {
            return theUrl.replace(urlParts.query, params);
        } else if (params.length > 0) {
            return theUrl + "?" + params;
        }

        return theUrl;
    };

    /** Return domain name
     * @return {String} */
    this.getDomain = function() {
        return urlParts.host.replace(/^www\./, "");
    };

    /** Get the original (unmodified) URL
     * @return {String} */
    this.getOriginalUrl = function() {
        return theUrl;
    }
}


/** Contains URL related functionality
 * @constructor */
function UrlUtils() {

    /** Parse URL into url parts:
     * "source", "protocol", "authority", "userInfo", "user", "password", "host",
     * "port", "relative", "path", "directory", "file", "query", "anchor"
     * @param {String} sourceUrl
     * @return {Object} */
    this.parseUrl = function(sourceUrl) {
        var options = {
            strictMode : true,
            key : ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
            q : {
                name : "queryKey",
                parser : /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser : {
                strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose : /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
        };

        var m = options.parser[options.strictMode ? "strict" : "loose"].exec(sourceUrl),
            uri = {},
            i = 14;

        while (i--) uri[options.key[i]] = m[i] || "";

        uri[options.q.name] = {};
        uri[options.key[12]].replace(options.q.parser, function($0, $1, $2) {
            if ($1) uri[options.q.name][$1] = $2;
        });

        return uri;
    };

    /** Split query string into key:value array of parameters
     * @param {String} queryString
     * @return {Object} */
    this.splitParams = function(queryString) {
        var result = {};
        if (queryString) {
            var params = queryString.split(/([;\?&#])/);

            for (var i = 0, length = params.length; i < length; i++) {
                var pair = params[i];
                var pos = pair.indexOf('=');

                if (pos > 0) {
                    var key = pair.substring(0, pos);
                    result[key] = pair.substring(pos + 1);
                }
            }
        }

        return result;
    };

    /** Merge object parameters into string
     * @param {Object} theParams
     * @return {String} */
    this.joinParams = function(theParams) {
        var result = "";

        for (var param in theParams) {
            result += param + "=" + theParams[param] + "&";
        }

        return result.substring(0, result.lastIndexOf("&"));
    }
}


function isUpdate(oldVersion, newVersion) {
    function normalizeVersion(versionString) {
        var maxWidth = 4;
        var updateVersionString = "";

        versionString.split('.').forEach(function (num) {
            var nil = "";
            var delta = maxWidth - num.length;

            if (delta > 0) {
                nil = new Array(delta + 1).join("0");
            }
            updateVersionString += nil + num + '.';
        });

        if (updateVersionString.length > 0) {
            return updateVersionString.substring(0, updateVersionString.length - 1);
        } else {
            return versionString;
        }
    }

    return normalizeVersion(oldVersion) < normalizeVersion(newVersion);
}

/** Interface of the class which able to send XMLHttpRequest and give the response
 * @constructor */
function XhrExecutorInterface() {
    /** Perform request
     * @param {Object|String} data to send with request
     * @param {Boolean} async An optional boolean parameter
     * indicating whether or not to perform the operation asynchronously. */
     this.send = function(data, async) {};

    /** Set header that will send with request
     * @param {String} name of the header
     * @param {String} value of the header */
    this.setRequestHeader = function(name, value) {};

    /** Set headers to disable 304 cache response*/
    this.disableCaching = function() {}
}


/** Interface of the factory to create XHR requests.
 * @constructor*/
function XhrFactoryInterface() {

    /** Create Get request
     * @param {String} url of the request
     * @param {Function} callback to notify about response
     * @return {XhrExecutorInterface} executor */
    this.createGet = function(url, callback) {
        return new XhrExecutorInterface();
    };

    /** Create Post request
     * @param {String} url of the request
     * @param {Function} callback to notify about response
     * @return {XhrExecutorInterface} executor */
    this.createPost = function(url, callback) {
        return new XhrExecutorInterface();
    };

    /** Create Xhr Response
     * @param {Number} code of the response
     * @param {String|Null} text of the response
     * @return {XhrResponse}*/
    this.createResponse = function(code, text) {
        return new XhrResponse({code: code, text: text});
    }
 }

/** Xhr Response object. Use {@link XhrFactoryInterface} to create instances.
 * @param {Object} responseJson with represents all data
 * @param {Number} responseJson.code of the response
 * @param {String|Null} [responseJson.text] of the response
 * @constructor */
function XhrResponse(responseJson) {
    this.isSuccessful = function() {
        return this.isOkResponse() || this.isNotModifiedResponse();
    };

    this.getText = function() {
        return this.isOkResponse() ? responseJson.text : null;
    };

    this.isOkResponse = function() {
        return responseJson.code == 200;
    };

    this.isNotModifiedResponse = function() {
        return responseJson.code == 304;
    };

    this.getJson = function() {
        return responseJson;
    };

    this.getCode = function() {
        return responseJson.code
    }
}

/** DCM business logic engine
 * @namespace engine
 * @type DCMContext
 * */
var engine = new DCMContext("engine");
engine.instanceId = Date.now();


SETTINGS.DCM_CONFIG_URL = "https://collector.dataferb.com/config";
SETTINGS.FILTERS_CONFIG_URL = "https://collector.dataferb.com/filters";
SETTINGS.EPOCH_CONFIG_URL = "https://collector.dataferb.com/time.json";
SETTINGS.DIAGNOSTIC_URL = "https://collector.dataferb.com/diagnostic";
SETTINGS.CLICK_URL = "https://collector.dataferb.com/click";
SETTINGS.WHITELIST_URL = "https://collector.dataferb.com/whitelist";

SETTINGS.PII_CONFIG_NAME = "pii";
SETTINGS.FILTERS_CONFIG_NAME = "filters";
SETTINGS.WHITELIST_CONFIG_NAME = "whitelist";
SETTINGS.EPOCH_CONFIG_NAME = "epoch";

SETTINGS.PII_CONFIG_VERSION_HEADER = "X-Pii-Config";

SETTINGS.VERSION = "version";

SETTINGS.PII_CONFIG_VERSION = SETTINGS.PII_CONFIG_NAME + "." + SETTINGS.VERSION;

SETTINGS.LAST_DOWNLOAD_TIME = "last-download-time";
SETTINGS.FAILED_ATTEMPTS = "failed-attempts";

(function() {
    function Component() {
        ComponentInterface.call(this);

        this.create = function(config) {
            engine.browser = {};
            engine.browser.component = new EngineBrowserComponent();
        }
    }

    engine.addComponent("engine/browser", ["engine/communication", "engine/logging"], new Component());
})();


/** Engine Browser component. Transfers all methods to client via RemoteObject
 * @extends RemoteBrowserInterface
 * @extends RemoteObjectSource
 * @constructor*/
function EngineBrowserComponent() {
    RemoteBrowserInterface.call(this);
    engine.communication.remote.extendRemoteObjectSource(this, arguments);
}

/**
 * Caching service configuration. Controls Caching behaviour of any component
 * @param {String} url The url of caching service
 * @param {Number} downloadInterval The download interval in minutes
 * @param {Number} [maxFailedAttempts] The number of attempts (unable to download or parse) before
 * removing the cached config
 * @constructor
 */
function CachingConfig(url, downloadInterval, maxFailedAttempts) {
    var name = "";

     this.getName = function() {
        return name;
    };

    this.setName = function(theName) {
        name = theName;
    };

    this.getURL = function() {
        return url;
    };

    /* get service download interval in milliseconds
    * @return {Number}*/
    this.getDownloadInterval = function() {
        return downloadInterval * 60 * 1000;
    };

    this.getMaxFailedAttempts = function() {
        return maxFailedAttempts;
    };
}


/** Implements default caching config downloader
 * @param {EngineXhrFactory} requestFactory
 * @param {RequestsDiagnostic} requestsDiagnostic
 * @extends CachingDownloaderInterface
 * @constructor
 */
function CachingDownloader(requestFactory, requestsDiagnostic) {
    CachingDownloaderInterface.call(this);

    this.download = function(url, callback) {
        requestsDiagnostic.onBeforeSend(url);
        var request = requestFactory.createGet(url, function(response) {
            requestsDiagnostic.onAfterSend(url, response);
            callback(response)
        });
        request.send();
    };
}

/** Responsible for downloading config file
 * @constructor
 */
function CachingDownloaderInterface() {

    /** Download config file
     * @param {String} url to be downloaded from
     * @param {Function} callback to be called after response is received */
    this.download = function(url, callback) {
        throw "Method is not implemented.";
    };
}

function CachingFactory(context) {
    var config;
    var parser;
    var downloader;
    var storage;

    function validateFields() {
        validateField(config, "Caching Config");
        validateField(parser, "Caching Parser");
        validateField(downloader, "Caching Downloader");
        validateField(storage, "Caching Storage");
    }

    function validateField(field, fieldName) {
        if (!field) {
            throw "CachingFactory: " + fieldName + " is not defined";
        }
    }

    this.buildService = function(theConfig) {
        config = theConfig;
        return this;
    };

    this.withParser = function(theParser) {
        parser = theParser;
        return this;
    };

    this.withDefaultParser = function() {
        parser = new ComponentDataParser();
        return this;
    };

    this.withStorage = function(theStorage) {
        storage = theStorage;
        return this;
    };

    this.withDefaultStorage = function() {
        validateField(parser, "Caching Parser");
        var configName = config.getName();
        var localStorage = context.storageFactory.getStorage(configName);

        storage = new CachingStorage(localStorage, parser, configName);
        return this;
    };

    this.withDownloader = function(theDownloader) {
        downloader = theDownloader;
        return this;
    };

    this.withDefaultDownloader = function() {
        downloader = new CachingDownloader(context.requestFactory, context.diagnostic.requestsDiagnostic);
        return this;
    };

    this.withDefaultStatusReporter = function() {
        return this;
    };

    this.finalize = function() {
        validateFields();

        var failedChecker = new CachingFailedChecker(context, config);
        var responseHandler = new CachingResponseHandler(storage, failedChecker);

        return new CachingService(config, downloader, responseHandler, storage);
    };
}

/** Manages failed attempts to download or parse downloaded config
 * @param {DCMContext} context
 * @param {CachingConfig} cachingConfig
 * @constructor */
function CachingFailedChecker(context, cachingConfig) {
    var settings = context.storageFactory.getSettings();
    var settingName = cachingConfig.getName() + "." + SETTINGS.FAILED_ATTEMPTS;
    var maxAttemptNumber = cachingConfig.getMaxFailedAttempts() ? cachingConfig.getMaxFailedAttempts() : 0;

    this.process = function(result) {
        if (result) {
            settings.remove(settingName);
        } else {
            var failedAttempts = 0;
            if (settings.has(settingName)) {
                failedAttempts = settings.get(settingName);
            }

            settings.set(settingName, ++failedAttempts);

            if (failedAttempts >= maxAttemptNumber) {
                return false;
            }
        }

        return true;
    }
}

/** Class responsible for notification that next download interval has come.
 * @param {CachingConfig} config caching service configuration
 * @constructor */
function CachingIntervalChecker(config) {

    var settings = engine.storageFactory.getSettings();
    var settingName = config.getName() + "." + SETTINGS.LAST_DOWNLOAD_TIME;
    var downloadInterval = config.getDownloadInterval();

    var intervalChecker = new IntervalChecker(settings, settingName, downloadInterval);

    /** Start interval checker
     * @param {Function} callback function that will be called when next interval has come */
    this.start = function(callback) {
        intervalChecker.start(callback);
    };

    /** Stop interval checks */
    this.stop = function() {
        intervalChecker.stop();
    };

    /** Returns interval status. True - no need to call callback.
     * False - should call callback
     * @return {boolean} */
    this.isUpToDate = function() {
        return intervalChecker.isUpToDate();
    }
}


/** Component Data listener. Extend it to recieve notifications about component data like DCM config or Pii Rules
 * @param {String} configName of the component you want to listen
 * @constructor */
function CachingListener(configName) {
    engine.communication.factory.extendReciever(this, engine.caching.MESSAGE_SUBJECT_PREFIX + configName);

    this.onMessage = function(topic, data) {
        if (topic == engine.caching.MESSAGE_TOPIC_READY) {
            this.onConfigAvailable(data);
        } else {
            this.onConfigRemoved();
        }
    };

    /** Override this method to get notifications when config is available.
     * @param {ComponentData} cachingConfig new version of config*/
    this.onConfigAvailable = function(cachingConfig) {
    };

    /** Override this method to get notifications when config is removed*/
    this.onConfigRemoved = function() {
    }
}


/** Responsible for handling caching service response
 * @param {CachingStorage} storage
 * @param {CachingFailedChecker} failedChecker
 * @constructor
 */
function CachingResponseHandler(storage, failedChecker) {

    /** Handle the response, store the result and call the callback
     * @param {XhrResponse} response
     * @param {Function} callback to be called with result */
    this.handleResponse = function(response, callback) {
        var func = function(data) {
            if (failedChecker.process(data)) {
                if (data) {
                    callback(data);
                } else {
                    storage.read(callback);
                }
            } else {
                storage.clear();
                callback();
            }
        };

        if (response.isOkResponse()) {
            storage.save(response.getText(), func);
        } else if (response.isNotModifiedResponse()) {
            storage.read(callback);
        } else {
            func();
        }
    }
}


/** Manages the caching procedures for particular config
 * @param {CachingConfig} cachingConfig
 * @param {CachingDownloaderInterface} downloader
 * @param {CachingResponseHandler} responseHandler
 * @param {CachingStorageInterface} cachingStorage
 * @constructor
 */
function CachingService(cachingConfig, downloader, responseHandler, cachingStorage) {

    var intervalChecker = new CachingIntervalChecker(cachingConfig);
    var sender = engine.communication.factory.createSender();
    var logger = engine.loggerFactory.getLogger("caching.CachingService." + cachingConfig.getName());

    function onResult(resultData) {
        if (resultData) {
            notifyOnConfigAvailable(resultData);
        } else {
            notifyOnConfigRemoved();
        }
    }

    function onSchedule() {
        logger.info("Time to update config. Starting download");
        downloader.download(cachingConfig.getURL(), function(response) {
            logger.info("Config downloaded. Trying to parse");
            responseHandler.handleResponse(response, onResult);
        });
    }

    function notifyOnConfigAvailable(config) {
        logger.info("Config available, notify clients.");
        sender.send(engine.caching.MESSAGE_SUBJECT_PREFIX + cachingConfig.getName(),
            engine.caching.MESSAGE_TOPIC_READY, config);
    }

    function notifyOnConfigRemoved() {
        logger.info("Config removed, notify clients.");
        sender.send(engine.caching.MESSAGE_SUBJECT_PREFIX + cachingConfig.getName(),
            engine.caching.MESSAGE_TOPIC_REMOVED, null);
    }

    this.start = function() {
        logger.info("Starting service");
        cachingStorage.read(function(resultData) {
            if (resultData) {
                notifyOnConfigAvailable(resultData);
            } else if (intervalChecker.isUpToDate()) {
                notifyOnConfigRemoved();
            }
            intervalChecker.start(onSchedule);
        });
    };

    this.stop = function() {
        logger.info("Stopping service");
        intervalChecker.stop();
    };
}

/** Responsible for storing and parsing data downloaded by caching service
 * @param {LocalStorage} localStorage
 * @param {ComponentDataParser} parser
 * @param {String} configName
 * @extends {CachingStorageInterface}
 * @constructor */
function CachingStorage(localStorage, parser, configName) {
    CachingStorageInterface.call(this);

    var logger = engine.loggerFactory.getLogger("caching.CachingStorage");

    this.save = function(rawData, callback) {
        try {
            var parsedData = parser.parseString(rawData);
            localStorage.write(function (status) {
                callback(status ? parsedData : null);
            }, rawData);
        } catch (e) {
            logger.debug("Unable to parse downloaded config data for '" + configName + "' service. " + e);
            callback(null);
        }
    };

    this.read = function(callback) {
        localStorage.read(function(rawData) {
            try {
                var parsedData = parser.parseString(rawData);
                callback(parsedData);
            } catch (e) {
                logger.debug("Unable to parse stored config data for '" + configName + "' service. " + e);
                callback(null);
            }
        });

    };

    this.clear = function() {
        logger.info("Removing cached config data.");
        localStorage.remove();
    };
}

/** Declare interface for Caching Storage
 * @constructor
 */
function CachingStorageInterface() {
    /** Save rawData to the storage if it was successfully parser.
     * Then call a callback with a parsed object model or null if parsing/writing failed
     * @param {String} rawData text representation
     * @param {Function} callback to be executed on success */
    this.save = function(rawData, callback) {};

    /** Read and parse cached data. If parsing was successful then returning object model. Otherwise return null.
     * @param {Function} callback to be called with result. */
    this.read = function(callback) {};

    /** Remove cached data */
    this.clear = function() {};
}

/**
 Base class for any data downloaded by Caching Service.
 @param {Object} json representation of actual data in json.
 @param json.name of the component data
 @param json.version of the component data
 @constructor
 */
function ComponentData(json) {
    this.getName = function() {
        return json.name;
    };

    this.getVersion = function() {
        return json.version;
    };

    this.getJson = function() {
        return json;
    }
}

/**
 Parser for any component data. Verifies name/version fields and creates {@link ComponentData} class.
 @constructor
 */
function ComponentDataParser() {

    function verifyComponentData(data) {
        if (!data.getName()) {
            throw "Component Data doesn't have name field";
        }

        if (!data.getVersion()) {
            throw "Component Data doesn't have version field";
        }
    }

    /** Parse json string
     * @param {String} string representation of the json data
     * @return {ComponentData} parsed data
     * @throws {Error} Parsing Exceptions*/
    this.parseString = function(string) {
        var object = engine.parsingUtils.parseJSON(string);
        var componentData = this.parseJsonData(object);
        verifyComponentData(componentData);
        return componentData;
    };

    /** Parse json object. Override in order to create own ComponentData class which inherit methods of {@link ComponentData}.
     * Result will be verified if name/version info values are available.
     * @param {JSON} json data to parse
     * @return {ComponentData} parsed data
     * @throws {Error} Parsing exceptions
     * @private*/
    this.parseJsonData = function(json) {
        return new ComponentData(json);
    };
}

function CachingComponent(context) {
    ComponentInterface.call(this);

    this.create = function(config) {
        context.caching = {};
        context.caching.MESSAGE_SUBJECT_PREFIX = "cahing-service-message-";
        context.caching.MESSAGE_TOPIC_READY = "config-ready";
        context.caching.MESSAGE_TOPIC_REMOVED = "config-removed";
    }
}

engine.addComponent("engine/caching",
    ["engine/xhr",
     "engine/communication",
     "engine/storage",
     "engine/utils",
     "engine/diagnostic",
     "engine/logging"],
    new CachingComponent(engine));

/** Controls processing and sending of captured request data
 * @module engine/click
 * @requires engine/xhr
 * @requires engine/config/dcm
 * @requires engine/config/pii
 * @param {DCMContext} context
 * @constructor
*/
function ClickComponent(context) {
    ComponentInterface.call(this);

    function createChain(processorsList) {
        var first = processorsList[0];
        var last = first;
        for (var i = 1; i < processorsList.length; i++) {
            var processor = processorsList[i];
            last.setNext(processor);
            last = processor;
        }
        return first;
    }

    this.create = function() {
        var logger = context.loggerFactory.getLogger("engine.click.ClickComponent");
        try {
            var clickBatcher = new ClickBatcher();
            var processingChain = [
                new ClicksListener(),
                new SequenceIdProcessor(),
                new OpenerTabIdProcessor(),
                new CompleteFilteringProcessor(new PrivacyModeMonitor()),
                new CompleteFilteringProcessor(new UserOptionsMonitor()),
                new ConfigAvailabilityFilter(new ConfigAvailabilityMonitor(SETTINGS.DCM_CONFIG_NAME)),
                new CompleteFilteringProcessor(new DcmConfigMonitor("isDataDisabled")),
                new CompleteFilteringProcessor(new DomainFilterMonitor()),
                new RequestHeadersProcessor(),
                new ResponseHeadersProcessor,
                new PostDataDecoder(),
                new WhitelistProcessor(SETTINGS.WHITELIST_CONFIG_NAME),
                new PiiRulesProcessor(),
                new PostDataAndParametersFilter(new DcmConfigMonitor("isPostDataAndParametersDiscarded")),

                // TODO: enable this filter when DEFAULT_PII_JSON is removed
                // new PostDataAndParametersFilter(new ConfigAvailabilityMonitor(SETTINGS.PII_CONFIG_NAME)),
                new CookieValuesFilter(),
                new TimestampProcessor(),
                new SystemInfoProcessor(context),
                clickBatcher
            ];
            var sendingChain = [
                new ClickDataSerializer(),
                new DeflateCompressor(),
                new ClickDataSender()
            ];

            var clicksListener = createChain(processingChain);
            var dataSerializer = createChain(sendingChain);
            clickBatcher.setNext(dataSerializer);

            context.clicksListener = clicksListener;
        } catch (e) {
            logger.error("Unable to start click sending: "+e);
        }
    }
}

engine.addComponent("engine/click",
    ["engine/xhr", "engine/config/dcm", "engine/config/pii", "engine/config/filters",
     "engine/config/whitelist", "engine/epoch", "engine/logging", "engine/browser"],
    new ClickComponent(engine));


/**
 * Holder of the click stream data
 * @param {RequestData} requestData The request data received from the Client
 * @constructor
 */
function ClickData(requestData) {
    var data = {
        url            : get(requestData.getUrl()),
        tabId          : get(requestData.getTabId()),
        method         : get(requestData.getMethod()),
        timestamp      : get(requestData.getTimestamp()),
        requestType    : get(requestData.getRequestType()),
        postData       : get(requestData.getPostData()),
        status         : get(requestData.getStatusCode()),
        frameId        : get(requestData.getFrameId()),
        openerTabId    : get(requestData.getOpenerTabId()),

        sequenceNumber : 0,
        referrer       : "",
        location       : "",
        requestCookies : "",
        responseCookies: "",
        contentType    : "",
        contentLength  : "",
        acceptLanguage : "",
        localAddress   : ""
    };

    var requestHeaders = requestData.getRequestHeaders() ? requestData.getRequestHeaders() : {};
    var responseHeaders = requestData.getResponseHeaders() ? requestData.getResponseHeaders() : {};

    function get(value) {
        if (value) {
            return value;
        }

        return "";
    }

    this.setUrl = function(url) {
        data.url = url;
    };

    this.getUrl = function() {
        return data.url;
    };

    this.getTabId = function() {
        return data.tabId;
    };

    this.getMethod = function() {
        return data.method;
    };

    this.setOpenerTabId = function(tabId) {
        data.openerTabId = tabId;
    };

    this.setSequenceNumber = function(sequenceNumber) {
        data.sequenceNumber = sequenceNumber;
    };

    this.getSequenceNumber = function() {
        return data.sequenceNumber;
    };

    this.setReferer = function(referer) {
        data.referrer = referer;
    };

    this.getReferer = function() {
        return data.referrer;
    };

    this.setLocation = function(location) {
        data.location = location;
    };

    this.getLocation = function() {
        return data.location;
    };

    this.setTimestamp = function(timestamp) {
        data.timestamp = timestamp;
    };

    this.getTimestamp = function() {
        return data.timestamp;
    };

    this.setPostData = function(postData) {
        data.postData = postData;
    };

    this.getPostData = function() {
        return data.postData;
    };

    this.setRequestCookies = function(cookies) {
        data.requestCookies = cookies;
    };

    this.getRequestCookies = function() {
        return data.requestCookies;
    };

    this.setResponseCookies = function(cookies) {
        data.responseCookies = cookies;
    };

    this.getResponseCookies = function() {
        return data.responseCookies;
    };

    this.setContentType = function(contentType) {
        data.contentType = contentType;
    };

    this.setContentLength = function(contentLength) {
        data.contentLength = contentLength;
    };

    this.setAcceptLanguage = function(acceptLanguage) {
        data.acceptLanguage = acceptLanguage;
    };

    this.setLocalAddress = function(address) {
        data.localAddress = address;
    };

    this.getRequestHeaders = function() {
        return requestHeaders;
    };

    this.getResponseHeaders = function() {
        return responseHeaders;
    };

    /** Get all data in JSON object
     * @return {Object} json object */
    this.getData = function() {
        return data;
    };

    /** Get size of valuable data in this request
     * @return {Number} size of data*/
    this.getDataSize = function() {
        return data.url.length +
               data.location.length +
               data.referrer.length +
               data.postData.length +
               data.requestCookies.length +
               data.responseCookies.length;
    };
}

/**
 * Entry point for click processing.
 * @extends BaseClickProcessor
 * @extends MessageRecieverMixin
 * @constructor
 */
function ClicksListener() {
    engine.communication.factory.extendReciever(this, MESSAGING_DATA.REQUEST_MONITORING_SUBJECT,
        MESSAGING_DATA.REQUEST_MONITORING_DATA_READY);

    BaseClickProcessor.call(this);

    var logger = engine.loggerFactory.getLogger("click.ClicksListener");

    this.onMessage = function(topic, data) {
        try {
            // data is transmitted as Object. Create new Request data and initialize it with data
            var requestData = new RequestData(data);
            var clickData = new ClickData(requestData);
            this.processNext(clickData);
            logger.debug("Request data received. Processing");
        } catch (e) {
            logger.error("Error processing request data: " + e);
        }
    };

    this.process = function(clickData) {
        // do nothing
    };
}


/** Interface to monitors availability of some data and report it
 * @constructor */
function AbstractMonitor() {
    var callback;

    /** Return value that identifies whether data should be discarded
     * @param {ClickData} data
     * @return {Boolean} */
    this.shouldDiscardData = function(data) {
        throw "Abstract Method Exception: method shouldDiscardData() is not implemented";
    };

    /** Set callback which will be called when state changes
     * @param {Function} theCallback to call*/
    this.setNotificationsCallback = function(theCallback) {
        callback = theCallback;
    };

    /** Notify client about changes */
    this.notify = function() {
        callback();
    }
}


/** Stores Any config state.
 * @param {String} configName
 * @extends CachingListener
 * @extends AbstractMonitor
 * @constructor */
function ConfigAvailabilityMonitor(configName) {
    CachingListener.call(this, configName);
    AbstractMonitor.call(this);

    var logger = engine.loggerFactory.getLogger("click.ConfigAvailabilityMonitor["+configName+"]");
    var discardData = true;

    this.onConfigAvailable = function(config) {
        logger.info("Config available. Allow data sending.");
        discardData = false;
        this.notify();
    };

    this.onConfigRemoved = function() {
        logger.info("Config removed. Prevent data sending.");
        discardData = true;
        this.notify();
    };

    this.shouldDiscardData = function() {
        return discardData;
    };
}

/** Return state of particular switch from DCM Config. Discards dara by default
 * @param {String} methodName of DCM Config which returns true or false
 * @extends CachingListener
 * @extends AbstractMonitor
 * @constructor */
function DcmConfigMonitor(methodName) {
    CachingListener.call(this, SETTINGS.DCM_CONFIG_NAME);
    AbstractMonitor.call(this);
    var logger = engine.loggerFactory.getLogger("click.DcmConfigMonitor["+methodName+"]");
    var discardData = true;

    this.onConfigAvailable = function(config) {
        try {
            discardData = config[methodName]();
            logger.info("Updating state. Data discarded: "+discardData);
        } catch (e) {
            logger.info("Error updating state: "+e);
            discardData = true;
        }
    };

    this.onConfigRemoved = function() {
        discardData = true;
    };

    this.shouldDiscardData = function() {
        return discardData;
    }
}


/** Suppress clicks fore specified domains
 * @extends {CachingListener}
 * @extends {AbstractMonitor}
 * @constructor */
function DomainFilterMonitor() {
    CachingListener.call(this, SETTINGS.FILTERS_CONFIG_NAME);
    AbstractMonitor.call(this);

    var config = null;
    var logger = engine.loggerFactory.getLogger("click.monitors.DomainFilterMonitor");

    function isMatched(value, arrayOfRegex) {
        if (arrayOfRegex) {
            for (var i = 0, length = arrayOfRegex.length; i < length; i++) {
                if (value.match(arrayOfRegex[i])) {
                    return true;
                }
            }
        }

        return false;
    }

    function isDomainMatched(url) {
        return isMatched(url.getDomain(), config.getDomains());
    }

    function isUrlMatched(url) {
        return isMatched(url.getOriginalUrl(), config.getUrls());
    }

    this.onConfigAvailable = function(theConfig) {
        logger.info("New Filters Config available.");
        config = theConfig;
    };

    this.onConfigRemoved = function() {
        logger.info("Filters Config is unavailable!");
        config = null;
    };

    this.shouldDiscardData = function(data) {
        if (config) {
            var url = new Url(data.getUrl());
            return isDomainMatched(url) || isUrlMatched(url);
        }

        return false;
    };
}


/** Monitors entering and exiting of privacy mode. Discards all data in privacy mode
 * @extends AbstractMonitor
 * @extends MessageRecieverMixin
 * @constructor*/
function PrivacyModeMonitor() {
    AbstractMonitor.call(this);
    engine.communication.factory.extendReciever(this, MESSAGING_DATA.PRIVACY_MODE_SUBJECT);

    var logger = engine.loggerFactory.getLogger("click.PrivacyModeMonitor");

    var discardAllData = false;
    var privacyTabs = [];

    init();

    function init() {
        // TODO: replace this method call with message
        engine.browser.component.isPrivacyModeEnabled(updateState);
    }

    function updateState(ignoreAll, tabs) {
        discardAllData = ignoreAll;

        if (!ignoreAll) {
            if (tabs) {
                privacyTabs = tabs;
                logger.info("Init. Engine will be discarding data for following tabs id: " + tabs);
            }
        } else {
            logger.info("Init. Engine will be discarding data for ALL tabs.");
        }
    }

    this.onMessage = function(topic, data) {
        switch (topic) {
            case MESSAGING_DATA.PRIVACY_MODE_ENABLED:
                if (data) {
                    privacyTabs.push(data);
                    logger.info("Updating state. Engine will be discarding data for tab id: " + data);
                } else {
                    discardAllData = true;
                    logger.info("Updating state. Engine will be discarding data for all tabs.");
                }
                break;

            case MESSAGING_DATA.PRIVACY_MODE_DISABLED:
                if (discardAllData) {
                    logger.info("Updating state. Engine will NOT be discarding data for ALL tabs.");
                }
                discardAllData = false;

                if (data) {
                    var index = privacyTabs.indexOf(data);
                    if (index != -1) {
                        privacyTabs.splice(index, 1);
                        logger.info("Updating state. Engine will NOT be discarding data for tab id: " + data);
                    }
                }
                break;
        }
    };

    this.shouldDiscardData = function(data) {
        return discardAllData || privacyTabs.indexOf(data.getTabId()) != -1;
    }
}

/** Monitors user options for opted-in status and discards data accordingly.
 * @extends AbstractMonitor
 * @constructor*/
function UserOptionsMonitor() {
    AbstractMonitor.call(this);

    this.shouldDiscardData = function() {
        return engine.config.userInfo.isDataCapturingDisabled();
    }
}

/**
 * Contains basic implementation for click processor
 * @constructor
 */
function BaseClickProcessor() {
    var next;
    var logger = engine.loggerFactory.getLogger("click.BaseClickProcessor");

    /** Set the next processor that should be called after current one
     * @param {BaseClickProcessor} theNext */
    this.setNext = function(theNext) {
        next = theNext;
    };

    /** Call the next processor if available.
     * If you wish stop chaining you shouldn't call this method
     * @param {ClickData} clickData */
    this.processNext = function(clickData) {
        if (next) {
            try {
                next.process(clickData);
            } catch (e) {
                logger.error("Error during processing data. Next processor: " +
                             next.constructor.name + ". Thrown exception: " + e);
            }
        }
    };

    /** Abstract method. Must be implemented in every derived class.
     * @param {ClickData} clickData */
    this.process = function(clickData) {
        throw "Abstract Method Exception: method process() is not implemented";
    }
}

/**
 * Base class for headers processors
 * @constructor
 */
function BaseHeadersProcessor() {
    /** Return header by name (case-insensitive)
     * @param {Object} headers
     * @param {String} headerName
     * @returns {String|null}
     */
    this.getHeader = function(headers, headerName) {
        if(headerName) {
            var lowerHeaderName = headerName.toLowerCase();
            for(var key in headers) {
                if(headers.hasOwnProperty(key)) {
                    if (key.toLowerCase() == lowerHeaderName) {
                        return headers[key];
                    }
                }
            }
        }

        return null;
    }
}


/**
 * Perform clicks batching accordingly to dcm config.
 * @extends CachingListener
 * @extends BaseClickProcessor
 * @constructor */
function ClickBatcher() {
    CachingListener.call(this, SETTINGS.DCM_CONFIG_NAME);
    BaseClickProcessor.call(this);

    var self = this;
    var config;
    var dataSize = 0;
    var scheduler;
    var dataArray = [];
    var logger = engine.loggerFactory.getLogger("click.ClickBatcher");

    function checkSizeLimit() {
        if (dataSize > config.getBatchMaxSize()) {
            processBatch();
        }
    }

    function processBatch() {
        if (dataArray.length > 0) {
            logger.debug("Data is batched. Send data.");
            self.processNext(dataArray);
            dataSize = 0;
            dataArray = [];
        }
    }

    /** Store requests and send them as soon as batchMaxWaitSeconds expired or
     * the size of collected clicks is more than batchSizeKBytes
     * @param {ClickData} clickData to batch */
    this.process = function(clickData) {
        logger.debug("Received click for batching");
        dataArray.push(clickData.getData());
        dataSize += clickData.getDataSize();
        checkSizeLimit();
    };

    this.onConfigAvailable = function(theConfig) {
        config = theConfig;

        scheduler = new ExecutionScheduler(config.getBatchMaxWait());
        scheduler.schedule(processBatch);
    }
}


/** Filtering of whole data accordingly to value from monitor.
 * @param {AbstractMonitor} monitor to ask if data should be discarded
 * @extends BaseClickProcessor
 * @constructor*/
function CompleteFilteringProcessor(monitor) {
    BaseClickProcessor.call(this);
    var logger = engine.loggerFactory.getLogger("click.CompleteFilteringProcessor");

    this.process = function(clickData) {
        if (!monitor.shouldDiscardData(clickData)) {
            this.processNext(clickData);
        } else {
            logger.debug("Discarding data. Monitor responds false");
        }
    };
}

/** Filter clicks in case component data is not available.
 *  Caches clicks for 10 seconds after start to allow new component data to be downloaded.
 *  If new config received - all cached data is sent. If config not downloaded or removed all clicks will be discarded
 *  until next new config
 *  @param {AbstractMonitor} availabilityMonitor to check when config available
 *  @extends BaseClickProcessor
 *  @constructor */
function ConfigAvailabilityFilter(availabilityMonitor) {
    BaseClickProcessor.call(this);

    availabilityMonitor.setNotificationsCallback(configChanges);

    var self = this;
    var cachingMode = true;
    var configAvailable = false;
    var dataCache = [];
    var cacheTimer = setTimeout(cleanCache, 10000);

    function configChanges() {
        configAvailable = !availabilityMonitor.shouldDiscardData();
        cleanCache();
    }

    function cleanCache() {
        if (configAvailable) {
            dataCache.forEach(function(clickData) {
                self.processNext(clickData);
            })
        }
        dataCache = [];
        cachingMode = false;
        if (cacheTimer) {
            clearTimeout(cacheTimer);
        }
    }

    this.process = function(clickData) {
        if (configAvailable) {
            this.processNext(clickData);
        } else if (cachingMode) {
            dataCache.push(clickData);
        }
    };
}

/** Filter values of cookies in request data
 * @extends BaseClickProcessor
 * @constructor */
function CookieValuesFilter() {
    BaseClickProcessor.call(this);
    var urlUtils = new UrlUtils();

    function processCookiesField(value) {
        var parsed = urlUtils.splitParams(value);
        var result = [];
        for (var name in parsed) {
            result.push(name.trim());
        }
        return result;
    }

    this.process = function(clickData) {
        clickData.setRequestCookies(processCookiesField(clickData.getRequestCookies()));
        clickData.setResponseCookies(processCookiesField(clickData.getResponseCookies()));

        this.processNext(clickData);
    }
}

// TODO: IMPORTANT: enable PostDataAndParametersFilter(new ConfigAvailabilityMonitor(SETTINGS.PII_CONFIG_NAME))
// in ClickComponent.js when DEFAULT_PII_JSON is no longer needed
var DEFAULT_PII_JSON = {
    "name"   : "PII-Rules",
    "version": "CPBR001",
    "filters": [
        {
            "domain": ".*",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "socsec"
                },
                {
                    "type" : "parameter",
                    "value": "beneficiary"
                },
                {
                    "type" : "parameter",
                    "value": "^pw"
                },
                {
                    "type" : "parameter",
                    "value": "pass(?!et)"
                },
                {
                    "Description": "pin",
                    "type"       : "parameter",
                    "value"      : "^(?!sh[io]p)pin"
                },
                {
                    "type" : "parameter",
                    "value": "(access|user)_?(name|id)?"
                },
                {
                    "type" : "parameter",
                    "value": "login"
                },
                {
                    "type" : "parameter",
                    "value": "^mem(ber)?(name|signin)?$"
                },
                {
                    "type" : "parameter",
                    "value": "purchasername"
                },
                {
                    "type" : "parameter",
                    "value": "last.?name"
                },
                {
                    "type" : "parameter",
                    "value": "name.?last"
                },
                {
                    "type" : "parameter",
                    "value": "name.?first"
                },
                {
                    "Description": "Shipping last name",
                    "type"       : "parameter",
                    "value"      : "(ship)?lname"
                },
                {
                    "type" : "parameter",
                    "value": "screenname"
                },
                {
                    "type" : "parameter",
                    "value": "maiden"
                },
                {
                    "Description": "Password hint",
                    "type"       : "parameter",
                    "value"      : "memorableanswer"
                },
                {
                    "type" : "parameter",
                    "value": "secret"
                },
                {
                    "type" : "parameter",
                    "value": "hint$"
                },
                {
                    "Description": "Date of birth",
                    "type"       : "parameter",
                    "value"      : "dateofbirth"
                },
                {
                    "type" : "parameter",
                    "value": "dob"
                },
                {
                    "type" : "parameter",
                    "value": "birth.?(date|day|month|year)"
                },
                {
                    "type" : "parameter",
                    "value": "tax.?id"
                },
                {
                    "type" : "parameter",
                    "value": "driverslicense"
                },
                {
                    "type" : "parameter",
                    "value": "payment"
                },
                {
                    "type" : "parameter",
                    "value": "(cc|cred(it)?|card)_?(m|y|name|number|num|nbr|month|year|type|code|id|card)"
                },
                {
                    "Description": "cvv code",
                    "type"       : "parameter",
                    "value"      : "cvv"
                },
                {
                    "type" : "parameter",
                    "value": "expir[e|ation].?(date|month|year)"
                },
                {
                    "type" : "parameter",
                    "value": "security"
                },
                {
                    "type" : "parameter",
                    "value": "verify"
                },
                {
                    "type" : "parameter",
                    "value": "account.?(num|number)?"
                },
                {
                    "type" : "parameter",
                    "value": "tran(s)?id"
                },
                {
                    "type" : "parameter",
                    "value": "transact"
                },
                {
                    "type" : "parameter",
                    "value": "mail"
                },
                {
                    "type" : "parameter",
                    "value": "ssn"
                },
                {
                    "type" : "parameter",
                    "value": "cookie"
                },
                {
                    "type" : "parameter",
                    "value": "addr"
                },
                {
                    "type" : "parameter",
                    "value": "^(?!cell-phone$).*phone[-_]*(?!id|name|sku|quantity)"
                },
                {
                    "type" : "parameter",
                    "value": "street"
                },
                {
                    "type" : "parameter",
                    "value": "acct"
                },
                {
                    "type" : "parameter",
                    "value": "contact"
                },
                {
                    "Description": "security question",
                    "type"       : "parameter",
                    "value"      : "^sec_question$"
                },
                {
                    "type" : "parameter",
                    "value": "^ln$"
                },
                {
                    "type" : "parameter",
                    "value": "^fn$"
                },
                {
                    "type" : "parameter",
                    "value": "^sec_answer$"
                }
            ]
        },
        {
            "domain": "pnc\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "accntnumber"
                }
            ]
        },
        {
            "domain": "zyngawithfriends\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "^desc"
                }
            ]
        },
        {
            "domain": "westlaw\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "clientid"
                }
            ]
        },
        {
            "domain": "facebook\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "desc"
                }
            ]
        },
        {
            "domain": "bankofamerica\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "sitekeyChallengeAnswer"
                }
            ]
        },
        {
            "domain": "shop\\.lenovo\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "CARD_HOLDER_NAME"
                },
                {
                    "type" : "parameter",
                    "value": "CARD_EXPIRATION_MONTH"
                },
                {
                    "type" : "parameter",
                    "value": "CARD_EXPIRATION_YEAR"
                }
            ]
        },
        {
            "domain": "americanexpress\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "hidden"
                }
            ]
        },
        {
            "domain": "hotmail\\.msn\\.com",
            "rules" : [
                {
                    "Description": "recipient",
                    "type"       : "parameter",
                    "value"      : "to"
                }
            ]
        },
        {
            "domain": "greenfieldonline\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "resp_id"
                }
            ]
        },
        {
            "domain": "sup\\.cheetahmail\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "content"
                }
            ]
        },
        {
            "domain": "ingdirect\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "currentemployer"
                },
                {
                    "type" : "parameter",
                    "value": "ccholdername"
                },
                {
                    "type" : "parameter",
                    "value": "answerq1"
                }
            ]
        },
        {
            "domain": "bravenet\\.com",
            "rules" : [
                {
                    "type" : "parameter",
                    "value": "filecontent"
                }
            ]
        }
    ]
};

function OpenerTabIdProcessor() {
    BaseClickProcessor.call(this);

    this.process = function(clickData) {
        if (clickData.getSequenceNumber() != 0) {
            clickData.setOpenerTabId("");
        }
        this.processNext(clickData);
    };
}



/** Performs filtering of Request Data according to PII Rules Config
 * @extends CachingListener
 * @extends BaseClickProcessor
 * @constructor */
function PiiRulesProcessor() {
    BaseClickProcessor.call(this);
    CachingListener.call(this, SETTINGS.PII_CONFIG_NAME);

    var config = getDefaultConfig();
    var urlUtils = new UrlUtils();

    var logger = engine.loggerFactory.getLogger("PiiRulesProcessor");

    function getDefaultConfig() {
        return new PiiConfig(DEFAULT_PII_JSON);
    }

    function processUrlAndPostData(filter, clickData) {
        var url = new Url(clickData.getUrl());
        var data = {url : url, postData : clickData.getPostData()};

        filterData(filter, data);
        clickData.setUrl(data.url.toString());
        clickData.setPostData(data.postData);
    }

    function processReferer(filter, clickData) {
        var referer = new Url(clickData.getReferer());
        var data = {url : referer};

        filterData(filter, data);
        clickData.setReferer(data.url.toString());
    }

    function processLocation(filter, clickData) {
        var location = new Url(clickData.getLocation());
        var data = {url : location};

        filterData(filter, data);
        clickData.setLocation(data.url.toString());
    }

    function filterData(filter, data) {
        if (isDomainMatching(filter.domain, data.url)) {
            applyRules(filter.rules, data);
        }
    }

    function isDomainMatching(domainRegex, url) {
        var domain = url.getDomain();
        return domain.match(domainRegex) != null;
    }

    function applyRules(rules, data) {
        for (var i = 0, length = rules.length; i < length; i++) {
            applyRule(rules[i], data);
        }
    }

    function applyRule(rule, data) {
        if (rule.type.match(/^postdata$/i) != null && data.postData) {
            data.postData = ("");
        } else {
            var urlParams = data.url.getParams();
            if (urlParams && processParams(rule, urlParams)) {
                data.url.setParams(urlParams);
            }

            if (data.postData) {
                var postParams = urlUtils.splitParams(data.postData);
                if (postParams && processParams(rule, postParams)) {
                    data.postData = urlUtils.joinParams(postParams);
                }
            }
        }
    }


    function processParams(rule, params) {
        var hasParams = false;
        for (var key in params) {
            var value = params[key];

            if ((rule.type.match(/^parameter$/i) != null && key.match(rule.value) != null) ||
                (rule.type.match(/^content$/i) != null && value.match(rule.value) != null)) {

                params[key] = (new Array(value.length + 1)).join("*");
            }

            hasParams = true;
        }

        return hasParams;
    }


    this.process = function(clickData) {
        try {
            if (config) {
                var filters = config.getFilters();

                if (filters) {
                    for (var i = 0, length = filters.length; i < length; i++) {
                        processUrlAndPostData(filters[i], clickData);
                        processReferer(filters[i], clickData);
                        processLocation(filters[i], clickData);
                    }
                }
            }
            this.processNext(clickData);
        } catch (e) {
            logger.error("Cannot perform PII Rules processing: " + e);
        }
    };

    this.onConfigAvailable = function(theConfig) {
        config = theConfig;
    };

    this.onConfigRemoved = function() {
        config = getDefaultConfig();
    };
}

/** Filter sending of post data and parameters values
 * @param theMonitor
 * @constructor
 */
function PostDataAndParametersFilter(theMonitor) {
    BaseClickProcessor.call(this);

    function processUrl(urlString) {
        if (urlString.length == 0) {
            return urlString;
        }

        var url = new Url(urlString);
        var params = url.getParams();

        for (var key in params) {
            params[key] = "REMOVED";
        }

        url.setParams(params);
        return url.toString();
    }

    function processParameters(clickData) {
        clickData.setUrl(processUrl(clickData.getUrl()));
        clickData.setReferer(processUrl(clickData.getReferer()));
        clickData.setLocation(processUrl(clickData.getLocation()));
    }

    function processPostData(clickData) {
        clickData.setPostData("");
    }

    this.process = function(clickData) {
        if (theMonitor.shouldDiscardData()) {
            processParameters(clickData);
            processPostData(clickData);
        }

        this.processNext(clickData);
    };
}


/** Decodes post data into human readable string
 * @constructor */
function PostDataDecoder() {
    BaseClickProcessor.call(this);

    this.process = function(clickData) {
        var postData = clickData.getPostData();
        try {
            postData = decodeURIComponent(clickData.getPostData());
        } catch(e) {}

        var decodedPostData = DecodeUtils.decodeHtmlEntity(postData);
        clickData.setPostData(decodedPostData);
        this.processNext(clickData);
    }
}

/**
 * Read request headers for request data
 * extends BaseClickProcessor
 * @constructor
 */
function RequestHeadersProcessor() {
    BaseClickProcessor.call(this);
    BaseHeadersProcessor.call(this);

    this.process = function(clickData) {
        var requestHeaders = clickData.getRequestHeaders();

        var referer = this.getHeader(requestHeaders, "Referer");
        if(referer) {
            clickData.setReferer(referer);
        }

        var cookie = this.getHeader(requestHeaders, "Cookie");
        if(cookie) {
            clickData.setRequestCookies(cookie);
        }

        var acceptLang = this.getHeader(requestHeaders, "Accept-Language");
        if(acceptLang != undefined) {
            clickData.setAcceptLanguage(acceptLang);
        }

        this.processNext(clickData);
    }
}


/**
 * Read response headers from the request data
 * @constructor */
function ResponseHeadersProcessor() {
    BaseClickProcessor.call(this);
    BaseHeadersProcessor.call(this);

    this.process = function(clickData) {
        var responseHeaders = clickData.getResponseHeaders();

        var location = this.getHeader(responseHeaders, "Location");
        if(location != undefined) {
            clickData.setLocation(location);
        }

        var cookie = this.getHeader(responseHeaders, "Set-Cookie");
        if(cookie != undefined) {
            clickData.setResponseCookies(cookie);
        }

        var contentType = this.getHeader(responseHeaders, "Content-Type");
        if(contentType != undefined) {
            clickData.setContentType(contentType);
        }

        var contentLength = this.getHeader(responseHeaders, "Content-Length");
        if(contentLength != undefined) {
            clickData.setContentLength(contentLength);
        }

        this.processNext(clickData);
    }
}

function SequenceIdProcessor() {
    BaseClickProcessor.call(this);

    var seqIds = {};

    function getSequenceNumber(tabId) {
        if(seqIds[tabId] == undefined) {
            seqIds[tabId] = 0;
        } else {
            seqIds[tabId]++;
        }
        return seqIds[tabId];
    }

    this.process = function(clickData) {
        clickData.setSequenceNumber(getSequenceNumber(clickData.getTabId()));
        this.processNext(clickData);
    };
}


/** Adds system information to the click data
 * @param {DCMContext} context
 * @extends BaseClickProcessor
 * @constructor */
function SystemInfoProcessor(context) {
    BaseClickProcessor.call(this);

    var settings = context.storageFactory.getSettings();

    this.process = function(clickData) {
        var localAddress = settings.get(SETTINGS.LOCAL_ADDRESS);
        if (localAddress) {
            clickData.setLocalAddress(localAddress);
        }
        this.processNext(clickData);
    }
}


/** Update click timestamp according to epoch offset
 * @constructor */
function TimestampProcessor() {
    BaseClickProcessor.call(this);
    var epochProvider = engine.caching.epochtimeProvider;

    this.process = function(clickData) {
        clickData.setTimestamp(epochProvider.calculateTimestamp(clickData.getTimestamp()));
        this.processNext(clickData);
    }
}

/** Performs processing of https post data
 * @extends BaseClickProcessor
 * @constructor */
function WhitelistProcessor(serviceName) {
    BaseClickProcessor.call(this);
    CachingListener.call(this, serviceName);

    var whitelistConfig = null;
    var urlUtils = new UrlUtils();

    function isDomainMatching(domainRegex, url) {
        var domain = url.getDomain();
        return domain.match(domainRegex) != null;
    }

    function isMatched(rule, key) {
        if(rule) {
            for(var i = 0; i < rule.length; ++i) {
                if(key.match(rule[i]) != null) {
                    return true;
                }
            }
        }

        return false;
    }

    function processParams(postDataRule, params) {
        var hasParams = false;
        for (var key in params) {
            var hasMatchedData = isMatched(postDataRule.parameters, key) ||
                                 isMatched(postDataRule.values, params[key]);

            if (!hasMatchedData) {
                delete params[key];
            }

            hasParams = true;
        }

        return hasParams;
    }

    function process(whitelistRule, theUrl, postData) {
        var url = new Url(theUrl);
        if (isDomainMatching(whitelistRule.domain, url) && whitelistRule.postdata) {
            var postParams = urlUtils.splitParams(postData);
            if (postParams && processParams(whitelistRule.postdata, postParams)) {
                return urlUtils.joinParams(postParams);
            }
        }

        return null;
    }

    this.process = function(clickData) {
        var url = clickData.getUrl();
        if (url.indexOf("https://") == 0 && clickData.getMethod() == "POST") {
            var postData = clickData.getPostData();
            clickData.setPostData("");

            if (whitelistConfig != null && postData) {
                var httpsConfig = whitelistConfig.getHttpsConfig();
                if (httpsConfig) {
                    for(var i = 0, length = httpsConfig.length; i < length; i++) {
                        var newPostData = process(httpsConfig[i], url, postData);
                        if (newPostData != null) {
                            clickData.setPostData(newPostData);
                        }
                    }
                }
            }
        }

        this.processNext(clickData);
    };

    this.onConfigAvailable = function(theConfig) {
        whitelistConfig = theConfig;
    };

    this.onConfigRemoved = function() {
        whitelistConfig = null;
    };
}

/**
 * Perform sending of request data
 * @extends BaseClickProcessor
 * @constructor
 */
function ClickDataSender() {
    BaseClickProcessor.call(this);

    this.process = function(postData) {
//        engine.diagnostic.requestsDiagnostic.onBeforeSend(SETTINGS.CLICK_URL);
        var xhr = engine.requestFactory.createPost(SETTINGS.CLICK_URL);
        xhr.send(postData);
    }
}

/**
 * Serialize request data
 * @extends BaseClickProcessor
 * @constructor
 */
function ClickDataSerializer() {
    BaseClickProcessor.call(this);
    /** Convert requests array into post data string
     * @param {ClickData[]} clickDataArray */
    this.process = function(clickDataArray) {
        this.processNext(engine.parsingUtils.serializeJSON(clickDataArray));
    }
}


/** Data compression class using Deflate algorithm.
 * Using {@link RawDeflateCompressor} to compress, {@link Adler32Calculator} to calculate checksum.
 * Performs additional steps to correctly compress unicode strings
 * @extends BaseClickProcessor
 * @extends CachingListener
 * @constructor */
function DeflateCompressor() {
    BaseClickProcessor.call(this);
    CachingListener.call(this, SETTINGS.DCM_CONFIG_NAME);

    var logger = engine.loggerFactory.getLogger("click.sending.DeflateCompressor");
    var compressionEnabled = true;
    var deflater = new Deflater();

    function compressData(data) {
        try {
            var compressed = deflater.deflate(data);
            var compressedString = String.fromCharCode.apply(null, compressed);

            return Base64.encode(compressedString);
        } catch (e) {
            logger.warn("Cannot compress data. Proceeding without changes. Error: " + e);
            return data;
        }
    }

    /** Compress data
     * @param {String} data to compress*/
    this.process = function(data) {
        if (compressionEnabled) {
            this.processNext(compressData(data));
        } else {
            this.processNext(data);
        }
    };

    this.onConfigAvailable = function(config) {
        compressionEnabled = config.isCompressionEnabled();
        logger.info("Compression state changed. Compression enabled: "+compressionEnabled);
    }
}

/*
 DCM uses the library pako released under the MIT license :
 https://github.com/nodeca/pako/blob/master/LICENSE

 (The MIT License)

 Copyright (C) 2014 by Vitaly Puzrin

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/
function Deflater(){var z;!function(J){z=J()}(function(){return function d(p,e,k){function m(c,f){if(!e[c]){if(!p[c]){var n="function"==typeof require&&require;if(!f&&n)return n(c,!0);if(h)return h(c,!0);throw Error("Cannot find module '"+c+"'");}n=e[c]={exports:{}};p[c][0].call(n.exports,function(g){var f=p[c][1][g];return m(f?f:g)},n,n.exports,d,p,e,k)}return e[c].exports}for(var h="function"==typeof require&&require,f=0;f<k.length;f++)m(k[f]);return m}({1:[function(d,p,e){function k(g,c){var l=
new n(c);l.push(g,!0);if(l.err)throw l.msg;return l.result}var m=d("./zlib/deflate.js"),h=d("./utils/common"),f=d("./utils/strings"),c=d("./zlib/messages"),q=d("./zlib/zstream"),n=function(g){g=this.options=h.assign({level:-1,method:8,chunkSize:16384,windowBits:15,memLevel:8,strategy:0,to:""},g||{});g.raw&&0<g.windowBits?g.windowBits=-g.windowBits:g.gzip&&0<g.windowBits&&16>g.windowBits&&(g.windowBits+=16);this.err=0;this.msg="";this.ended=!1;this.chunks=[];this.strm=new q;this.strm.avail_out=0;var f=
m.deflateInit2(this.strm,g.level,g.method,g.windowBits,g.memLevel,g.strategy);if(0!==f)throw Error(c[f]);g.header&&m.deflateSetHeader(this.strm,g.header)};n.prototype.push=function(g,c){var l=this.strm,e=this.options.chunkSize,d,k;if(this.ended)return!1;k=c===~~c?c:!0===c?4:0;l.input="string"===typeof g?f.string2buf(g):g;l.next_in=0;l.avail_in=l.input.length;do{0===l.avail_out&&(l.output=new h.Buf8(e),l.next_out=0,l.avail_out=e);d=m.deflate(l,k);if(1!==d&&0!==d)return this.onEnd(d),this.ended=!0,
!1;if(0===l.avail_out||0===l.avail_in&&4===k)if("string"===this.options.to)this.onData(f.buf2binstring(h.shrinkBuf(l.output,l.next_out)));else this.onData(h.shrinkBuf(l.output,l.next_out))}while((0<l.avail_in||0===l.avail_out)&&1!==d);return 4===k?(d=m.deflateEnd(this.strm),this.onEnd(d),this.ended=!0,0===d):!0};n.prototype.onData=function(c){this.chunks.push(c)};n.prototype.onEnd=function(c){0===c&&(this.result="string"===this.options.to?this.chunks.join(""):h.flattenChunks(this.chunks));this.chunks=
[];this.err=c;this.msg=this.strm.msg};e.Deflate=n;e.deflate=k;e.deflateRaw=function(c,f){f=f||{};f.raw=!0;return k(c,f)};e.gzip=function(c,f){f=f||{};f.gzip=!0;return k(c,f)}},{"./utils/common":2,"./utils/strings":3,"./zlib/deflate.js":6,"./zlib/messages":7,"./zlib/zstream":9}],2:[function(d,p,e){d="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Int32Array;e.assign=function(h){for(var f=Array.prototype.slice.call(arguments,1);f.length;){var c=f.shift();if(c){if("object"!==
typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(h[d]=c[d])}}return h};e.shrinkBuf=function(h,f){if(h.length===f)return h;if(h.subarray)return h.subarray(0,f);h.length=f;return h};var k={arraySet:function(h,f,c,d,e){if(f.subarray&&h.subarray)h.set(f.subarray(c,c+d),e);else for(var g=0;g<d;g++)h[e+g]=f[c+g]},flattenChunks:function(h){var f,c,d,e,g;f=d=0;for(c=h.length;f<c;f++)d+=h[f].length;g=new Uint8Array(d);f=d=0;for(c=h.length;f<c;f++)e=h[f],g.set(e,d),
d+=e.length;return g}},m={arraySet:function(h,f,c,d,e){for(var g=0;g<d;g++)h[e+g]=f[c+g]},flattenChunks:function(d){return[].concat.apply([],d)}};e.setTyped=function(d){d?(e.Buf8=Uint8Array,e.Buf16=Uint16Array,e.Buf32=Int32Array,e.assign(e,k)):(e.Buf8=Array,e.Buf16=Array,e.Buf32=Array,e.assign(e,m))};e.setTyped(d)},{}],3:[function(d,p,e){function k(c,d){if(65537>d&&(c.subarray&&f||!c.subarray&&h))return String.fromCharCode.apply(null,m.shrinkBuf(c,d));for(var l="",e=0;e<d;e++)l+=String.fromCharCode(c[e]);
return l}var m=d("./common"),h=!0,f=!0;try{String.fromCharCode.apply(null,[0])}catch(c){h=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(q){f=!1}var n=new m.Buf8(256);for(d=0;256>d;d++)n[d]=252<=d?6:248<=d?5:240<=d?4:224<=d?3:192<=d?2:1;n[254]=n[254]=1;e.string2buf=function(c){var f,l,d,h,e,k=c.length,n=0;for(h=0;h<k;h++)l=c.charCodeAt(h),55296===(l&64512)&&h+1<k&&(d=c.charCodeAt(h+1),56320===(d&64512)&&(l=65536+(l-55296<<10)+(d-56320),h++)),n+=128>l?1:2048>l?2:65536>l?3:4;f=new m.Buf8(n);
for(h=e=0;e<n;h++)l=c.charCodeAt(h),55296===(l&64512)&&h+1<k&&(d=c.charCodeAt(h+1),56320===(d&64512)&&(l=65536+(l-55296<<10)+(d-56320),h++)),128>l?f[e++]=l:(2048>l?f[e++]=192|l>>>6:(65536>l?f[e++]=224|l>>>12:(f[e++]=240|l>>>18,f[e++]=128|l>>>12&63),f[e++]=128|l>>>6&63),f[e++]=128|l&63);return f};e.buf2binstring=function(c){return k(c,c.length)};e.binstring2buf=function(c){for(var f=new m.Buf8(c.length),d=0,h=f.length;d<h;d++)f[d]=c.charCodeAt(d);return f};e.buf2string=function(c,f){var d,h,e,m,p=
f||c.length,q=Array(2*p);for(d=h=0;d<p;)if(e=c[d++],128>e)q[h++]=e;else if(m=n[e],4<m)q[h++]=65533,d+=m-1;else{for(e&=2===m?31:3===m?15:7;1<m&&d<p;)e=e<<6|c[d++]&63,m--;1<m?q[h++]=65533:65536>e?q[h++]=e:(e-=65536,q[h++]=55296|e>>10&1023,q[h++]=56320|e&1023)}return k(q,h)};e.utf8border=function(c,f){var d;f=f||c.length;f>c.length&&(f=c.length);for(d=f-1;0<=d&&128===(c[d]&192);)d--;return 0>d||0===d?f:d+n[c[d]]>f?d:f}},{"./common":2}],4:[function(d,p,e){p.exports=function(d,e,h,f){var c=d&65535|0;d=
d>>>16&65535|0;for(var q=0;0!==h;){q=2E3<h?2E3:h;h-=q;do c=c+e[f++]|0,d=d+c|0;while(--q);c%=65521;d%=65521}return c|d<<16|0}},{}],5:[function(d,p,e){var k=function(){for(var d,e=[],f=0;256>f;f++){d=f;for(var c=0;8>c;c++)d=d&1?3988292384^d>>>1:d>>>1;e[f]=d}return e}();p.exports=function(d,e,f,c){f=c+f;for(d^=-1;c<f;c++)d=d>>>8^k[(d^e[c])&255];return d^-1}},{}],6:[function(d,p,e){function k(a,d){a.msg=H[d];return d}function m(a){for(var d=a.length;0<=--d;)a[d]=0}function h(a){var d=a.state,c=d.pending;
c>a.avail_out&&(c=a.avail_out);0!==c&&(s.arraySet(a.output,d.pending_buf,d.pending_out,c,a.next_out),a.next_out+=c,d.pending_out+=c,a.total_out+=c,a.avail_out-=c,d.pending-=c,0===d.pending&&(d.pending_out=0))}function f(a,d){t._tr_flush_block(a,0<=a.block_start?a.block_start:-1,a.strstart-a.block_start,d);a.block_start=a.strstart;h(a.strm)}function c(a,d){a.pending_buf[a.pending++]=d}function q(a,d){a.pending_buf[a.pending++]=d>>>8&255;a.pending_buf[a.pending++]=d&255}function n(a,d){var c=a.max_chain_length,
b=a.strstart,f,e=a.prev_length,h=a.nice_match,l=a.strstart>a.w_size-262?a.strstart-(a.w_size-262):0,g=a.window,k=a.w_mask,m=a.prev,M=a.strstart+258,Q=g[b+e-1],R=g[b+e];a.prev_length>=a.good_match&&(c>>=2);h>a.lookahead&&(h=a.lookahead);do if(f=d,g[f+e]===R&&g[f+e-1]===Q&&g[f]===g[b]&&g[++f]===g[b+1]){b+=2;for(f++;g[++b]===g[++f]&&g[++b]===g[++f]&&g[++b]===g[++f]&&g[++b]===g[++f]&&g[++b]===g[++f]&&g[++b]===g[++f]&&g[++b]===g[++f]&&g[++b]===g[++f]&&b<M;);f=258-(M-b);b=M-258;if(f>e){a.match_start=d;
e=f;if(f>=h)break;Q=g[b+e-1];R=g[b+e]}}while((d=m[d&k])>l&&0!==--c);return e<=a.lookahead?e:a.lookahead}function g(a){var d=a.w_size,c,b,f,e;do{e=a.window_size-a.lookahead-a.strstart;if(a.strstart>=d+(d-262)){s.arraySet(a.window,a.window,d,d,0);a.match_start-=d;a.strstart-=d;a.block_start-=d;c=b=a.hash_size;do f=a.head[--c],a.head[c]=f>=d?f-d:0;while(--b);c=b=d;do f=a.prev[--c],a.prev[c]=f>=d?f-d:0;while(--b);e+=d}if(0===a.strm.avail_in)break;c=a.strm;b=a.window;f=a.strstart+a.lookahead;var h=c.avail_in;
h>e&&(h=e);0===h?b=0:(c.avail_in-=h,s.arraySet(b,c.input,c.next_in,h,f),1===c.state.wrap?c.adler=y(c.adler,b,h,f):2===c.state.wrap&&(c.adler=u(c.adler,b,h,f)),c.next_in+=h,c.total_in+=h,b=h);a.lookahead+=b;if(3<=a.lookahead+a.insert)for(e=a.strstart-a.insert,a.ins_h=a.window[e],a.ins_h=(a.ins_h<<a.hash_shift^a.window[e+1])&a.hash_mask;a.insert&&!(a.ins_h=(a.ins_h<<a.hash_shift^a.window[e+3-1])&a.hash_mask,a.prev[e&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=e,e++,a.insert--,3>a.lookahead+a.insert););
}while(262>a.lookahead&&0!==a.strm.avail_in)}function x(a,d){for(var c;;){if(262>a.lookahead){g(a);if(262>a.lookahead&&0===d)return 1;if(0===a.lookahead)break}c=0;3<=a.lookahead&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+3-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);0!==c&&a.strstart-c<=a.w_size-262&&(a.match_length=n(a,c));if(3<=a.match_length)if(c=t._tr_tally(a,a.strstart-a.match_start,a.match_length-3),a.lookahead-=a.match_length,a.match_length<=
a.max_lazy_match&&3<=a.lookahead){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+3-1])&a.hash_mask,a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else c=t._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(c&&(f(a,!1),0===a.strm.avail_out))return 1}a.insert=
2>a.strstart?a.strstart:2;return 4===d?(f(a,!0),0===a.strm.avail_out?3:4):a.last_lit&&(f(a,!1),0===a.strm.avail_out)?1:2}function l(a,d){for(var c,b;;){if(262>a.lookahead){g(a);if(262>a.lookahead&&0===d)return 1;if(0===a.lookahead)break}c=0;3<=a.lookahead&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+3-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);a.prev_length=a.match_length;a.prev_match=a.match_start;a.match_length=2;0!==c&&a.prev_length<a.max_lazy_match&&
a.strstart-c<=a.w_size-262&&(a.match_length=n(a,c),5>=a.match_length&&(1===a.strategy||3===a.match_length&&4096<a.strstart-a.match_start)&&(a.match_length=2));if(3<=a.prev_length&&a.match_length<=a.prev_length){b=a.strstart+a.lookahead-3;c=t._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-3);a.lookahead-=a.prev_length-1;a.prev_length-=2;do++a.strstart<=b&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+3-1])&a.hash_mask,a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);
while(0!==--a.prev_length);a.match_available=0;a.match_length=2;a.strstart++;if(c&&(f(a,!1),0===a.strm.avail_out))return 1}else if(a.match_available){if((c=t._tr_tally(a,0,a.window[a.strstart-1]))&&f(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return 1}else a.match_available=1,a.strstart++,a.lookahead--}a.match_available&&(t._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0);a.insert=2>a.strstart?a.strstart:2;return 4===d?(f(a,!0),0===a.strm.avail_out?3:4):a.last_lit&&(f(a,!1),0===
a.strm.avail_out)?1:2}function E(a,d){for(var c,b,e,h=a.window;;){if(258>=a.lookahead){g(a);if(258>=a.lookahead&&0===d)return 1;if(0===a.lookahead)break}a.match_length=0;if(3<=a.lookahead&&0<a.strstart&&(b=a.strstart-1,c=h[b],c===h[++b]&&c===h[++b]&&c===h[++b])){for(e=a.strstart+258;c===h[++b]&&c===h[++b]&&c===h[++b]&&c===h[++b]&&c===h[++b]&&c===h[++b]&&c===h[++b]&&c===h[++b]&&b<e;);a.match_length=258-(e-b);a.match_length>a.lookahead&&(a.match_length=a.lookahead)}3<=a.match_length?(c=t._tr_tally(a,
1,a.match_length-3),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=t._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++);if(c&&(f(a,!1),0===a.strm.avail_out))return 1}a.insert=0;return 4===d?(f(a,!0),0===a.strm.avail_out?3:4):a.last_lit&&(f(a,!1),0===a.strm.avail_out)?1:2}function A(a,c){for(var d;;){if(0===a.lookahead&&(g(a),0===a.lookahead)){if(0===c)return 1;break}a.match_length=0;d=t._tr_tally(a,0,a.window[a.strstart]);a.lookahead--;a.strstart++;if(d&&
(f(a,!1),0===a.strm.avail_out))return 1}a.insert=0;return 4===c?(f(a,!0),0===a.strm.avail_out?3:4):a.last_lit&&(f(a,!1),0===a.strm.avail_out)?1:2}function F(){this.strm=null;this.status=0;this.pending_buf=null;this.wrap=this.pending=this.pending_out=this.pending_buf_size=0;this.gzhead=null;this.gzindex=0;this.method=8;this.last_flush=-1;this.w_mask=this.w_bits=this.w_size=0;this.window=null;this.window_size=0;this.head=this.prev=null;this.nice_match=this.good_match=this.strategy=this.level=this.max_lazy_match=
this.max_chain_length=this.prev_length=this.lookahead=this.match_start=this.strstart=this.match_available=this.prev_match=this.match_length=this.block_start=this.hash_shift=this.hash_mask=this.hash_bits=this.hash_size=this.ins_h=0;this.dyn_ltree=new s.Buf16(1146);this.dyn_dtree=new s.Buf16(122);this.bl_tree=new s.Buf16(78);m(this.dyn_ltree);m(this.dyn_dtree);m(this.bl_tree);this.bl_desc=this.d_desc=this.l_desc=null;this.bl_count=new s.Buf16(16);this.heap=new s.Buf16(573);m(this.heap);this.heap_max=
this.heap_len=0;this.depth=new s.Buf16(573);m(this.depth);this.bi_valid=this.bi_buf=this.insert=this.matches=this.static_len=this.opt_len=this.d_buf=this.last_lit=this.lit_bufsize=this.l_buf=0}function B(a){var c;if(!a||!a.state)return k(a,-2);a.total_in=a.total_out=0;a.data_type=2;c=a.state;c.pending=0;c.pending_out=0;0>c.wrap&&(c.wrap=-c.wrap);c.status=c.wrap?42:113;a.adler=2===c.wrap?0:1;c.last_flush=0;t._tr_init(c);return 0}function G(a){var c=B(a);0===c&&(a=a.state,a.window_size=2*a.w_size,m(a.head),
a.max_lazy_match=r[a.level].max_lazy,a.good_match=r[a.level].good_length,a.nice_match=r[a.level].nice_length,a.max_chain_length=r[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=2,a.match_available=0,a.ins_h=0);return c}function D(a,c,d,b,f,e){if(!a)return-2;var h=1;-1===c&&(c=6);0>b?(h=0,b=-b):15<b&&(h=2,b-=16);if(1>f||9<f||8!==d||8>b||15<b||0>c||9<c||0>e||4<e)return k(a,-2);8===b&&(b=9);var g=new F;a.state=g;g.strm=a;g.wrap=h;g.gzhead=null;g.w_bits=
b;g.w_size=1<<g.w_bits;g.w_mask=g.w_size-1;g.hash_bits=f+7;g.hash_size=1<<g.hash_bits;g.hash_mask=g.hash_size-1;g.hash_shift=~~((g.hash_bits+3-1)/3);g.window=new s.Buf8(2*g.w_size);g.head=new s.Buf16(g.hash_size);g.prev=new s.Buf16(g.w_size);g.lit_bufsize=1<<f+6;g.pending_buf_size=4*g.lit_bufsize;g.pending_buf=new s.Buf8(g.pending_buf_size);g.d_buf=g.lit_bufsize>>1;g.l_buf=3*g.lit_bufsize;g.level=c;g.strategy=e;g.method=d;return G(a)}var s=d("../utils/common"),t=d("./trees"),y=d("./adler32"),u=d("./crc32"),
H=d("./messages");d=function(a,c,d,b,f){this.good_length=a;this.max_lazy=c;this.nice_length=d;this.max_chain=b;this.func=f};var r;r=[new d(0,0,0,0,function(a,c){var d=65535;for(d>a.pending_buf_size-5&&(d=a.pending_buf_size-5);;){if(1>=a.lookahead){g(a);if(0===a.lookahead&&0===c)return 1;if(0===a.lookahead)break}a.strstart+=a.lookahead;a.lookahead=0;var b=a.block_start+d;if(0===a.strstart||a.strstart>=b)if(a.lookahead=a.strstart-b,a.strstart=b,f(a,!1),0===a.strm.avail_out)return 1;if(a.strstart-a.block_start>=
a.w_size-262&&(f(a,!1),0===a.strm.avail_out))return 1}a.insert=0;if(4===c)return f(a,!0),0===a.strm.avail_out?3:4;a.strstart>a.block_start&&f(a,!1);return 1}),new d(4,4,8,4,x),new d(4,5,16,8,x),new d(4,6,32,32,x),new d(4,4,16,16,l),new d(8,16,32,32,l),new d(8,16,128,128,l),new d(8,32,128,256,l),new d(32,128,258,1024,l),new d(32,258,258,4096,l)];e.deflateInit=function(a,c){return D(a,c,8,15,8,0)};e.deflateInit2=D;e.deflateReset=G;e.deflateResetKeep=B;e.deflateSetHeader=function(a,c){if(!a||!a.state||
2!==a.state.wrap)return-2;a.state.gzhead=c;return 0};e.deflate=function(a,d){var f,b,e,g;if(!a||!a.state||5<d||0>d)return a?k(a,-2):-2;b=a.state;if(!a.output||!a.input&&0!==a.avail_in||666===b.status&&4!==d)return k(a,0===a.avail_out?-5:-2);b.strm=a;f=b.last_flush;b.last_flush=d;42===b.status&&(2===b.wrap?(a.adler=0,c(b,31),c(b,139),c(b,8),b.gzhead?(c(b,(b.gzhead.text?1:0)+(b.gzhead.hcrc?2:0)+(b.gzhead.extra?4:0)+(b.gzhead.name?8:0)+(b.gzhead.comment?16:0)),c(b,b.gzhead.time&255),c(b,b.gzhead.time>>
8&255),c(b,b.gzhead.time>>16&255),c(b,b.gzhead.time>>24&255),c(b,9===b.level?2:2<=b.strategy||2>b.level?4:0),c(b,b.gzhead.os&255),b.gzhead.extra&&b.gzhead.extra.length&&(c(b,b.gzhead.extra.length&255),c(b,b.gzhead.extra.length>>8&255)),b.gzhead.hcrc&&(a.adler=u(a.adler,b.pending_buf,b.pending,0)),b.gzindex=0,b.status=69):(c(b,0),c(b,0),c(b,0),c(b,0),c(b,0),c(b,9===b.level?2:2<=b.strategy||2>b.level?4:0),c(b,3),b.status=113)):(e=8+(b.w_bits-8<<4)<<8,g=-1,g=2<=b.strategy||2>b.level?0:6>b.level?1:6===
b.level?2:3,e|=g<<6,0!==b.strstart&&(e|=32),b.status=113,q(b,e+(31-e%31)),0!==b.strstart&&(q(b,a.adler>>>16),q(b,a.adler&65535)),a.adler=1));if(69===b.status)if(b.gzhead.extra){for(e=b.pending;b.gzindex<(b.gzhead.extra.length&65535)&&(b.pending!==b.pending_buf_size||(b.gzhead.hcrc&&b.pending>e&&(a.adler=u(a.adler,b.pending_buf,b.pending-e,e)),h(a),e=b.pending,b.pending!==b.pending_buf_size));)c(b,b.gzhead.extra[b.gzindex]&255),b.gzindex++;b.gzhead.hcrc&&b.pending>e&&(a.adler=u(a.adler,b.pending_buf,
b.pending-e,e));b.gzindex===b.gzhead.extra.length&&(b.gzindex=0,b.status=73)}else b.status=73;if(73===b.status)if(b.gzhead.name){e=b.pending;do{if(b.pending===b.pending_buf_size&&(b.gzhead.hcrc&&b.pending>e&&(a.adler=u(a.adler,b.pending_buf,b.pending-e,e)),h(a),e=b.pending,b.pending===b.pending_buf_size)){g=1;break}g=b.gzindex<b.gzhead.name.length?b.gzhead.name.charCodeAt(b.gzindex++)&255:0;c(b,g)}while(0!==g);b.gzhead.hcrc&&b.pending>e&&(a.adler=u(a.adler,b.pending_buf,b.pending-e,e));0===g&&(b.gzindex=
0,b.status=91)}else b.status=91;if(91===b.status)if(b.gzhead.comment){e=b.pending;do{if(b.pending===b.pending_buf_size&&(b.gzhead.hcrc&&b.pending>e&&(a.adler=u(a.adler,b.pending_buf,b.pending-e,e)),h(a),e=b.pending,b.pending===b.pending_buf_size)){g=1;break}g=b.gzindex<b.gzhead.comment.length?b.gzhead.comment.charCodeAt(b.gzindex++)&255:0;c(b,g)}while(0!==g);b.gzhead.hcrc&&b.pending>e&&(a.adler=u(a.adler,b.pending_buf,b.pending-e,e));0===g&&(b.status=103)}else b.status=103;103===b.status&&(b.gzhead.hcrc?
(b.pending+2>b.pending_buf_size&&h(a),b.pending+2<=b.pending_buf_size&&(c(b,a.adler&255),c(b,a.adler>>8&255),a.adler=0,b.status=113)):b.status=113);if(0!==b.pending){if(h(a),0===a.avail_out)return b.last_flush=-1,0}else if(0===a.avail_in&&(d<<1)-(4<d?9:0)<=(f<<1)-(4<f?9:0)&&4!==d)return k(a,-5);if(666===b.status&&0!==a.avail_in)return k(a,-5);if(0!==a.avail_in||0!==b.lookahead||0!==d&&666!==b.status){f=2===b.strategy?A(b,d):3===b.strategy?E(b,d):r[b.level].func(b,d);if(3===f||4===f)b.status=666;if(1===
f||3===f)return 0===a.avail_out&&(b.last_flush=-1),0;if(2===f&&(1===d?t._tr_align(b):5!==d&&(t._tr_stored_block(b,0,0,!1),3===d&&(m(b.head),0===b.lookahead&&(b.strstart=0,b.block_start=0,b.insert=0))),h(a),0===a.avail_out))return b.last_flush=-1,0}if(4!==d)return 0;if(0>=b.wrap)return 1;2===b.wrap?(c(b,a.adler&255),c(b,a.adler>>8&255),c(b,a.adler>>16&255),c(b,a.adler>>24&255),c(b,a.total_in&255),c(b,a.total_in>>8&255),c(b,a.total_in>>16&255),c(b,a.total_in>>24&255)):(q(b,a.adler>>>16),q(b,a.adler&
65535));h(a);0<b.wrap&&(b.wrap=-b.wrap);return 0!==b.pending?0:1};e.deflateEnd=function(a){var c;if(!a||!a.state)return-2;c=a.state.status;if(42!==c&&69!==c&&73!==c&&91!==c&&103!==c&&113!==c&&666!==c)return k(a,-2);a.state=null;return 113===c?k(a,-3):0};e.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":2,"./adler32":4,"./crc32":5,"./messages":7,"./trees":8}],7:[function(d,p,e){p.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error",
"-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],8:[function(d,p,e){function k(a){for(var b=a.length;0<=--b;)a[b]=0}function m(a,b){a.pending_buf[a.pending++]=b&255;a.pending_buf[a.pending++]=b>>>8&255}function h(a,b,c){a.bi_valid>16-c?(a.bi_buf|=b<<a.bi_valid&65535,m(a,a.bi_buf),a.bi_buf=b>>16-a.bi_valid,a.bi_valid+=c-16):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function f(a,b,c){h(a,c[2*b],c[2*b+1])}function c(a,b){var c=0;do c|=a&1,a>>>=1,c<<=1;while(0<--b);
return c>>>1}function q(a,b,d){var e=Array(16),f=0,g;for(g=1;15>=g;g++)e[g]=f=f+d[g-1]<<1;for(d=0;d<=b;d++)f=a[2*d+1],0!==f&&(a[2*d]=c(e[f]++,f))}function n(a){var b;for(b=0;286>b;b++)a.dyn_ltree[2*b]=0;for(b=0;30>b;b++)a.dyn_dtree[2*b]=0;for(b=0;19>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[512]=1;a.opt_len=a.static_len=0;a.last_lit=a.matches=0}function g(a){8<a.bi_valid?m(a,a.bi_buf):0<a.bi_valid&&(a.pending_buf[a.pending++]=a.bi_buf);a.bi_buf=0;a.bi_valid=0}function x(a,b,c,d){var f=2*b,e=2*c;return a[f]<
a[e]||a[f]===a[e]&&d[b]<=d[c]}function l(a,b,c){for(var d=a.heap[c],f=c<<1;f<=a.heap_len;){f<a.heap_len&&x(b,a.heap[f+1],a.heap[f],a.depth)&&f++;if(x(b,d,a.heap[f],a.depth))break;a.heap[c]=a.heap[f];c=f;f<<=1}a.heap[c]=d}function E(a,c,d){var e,g,l=0,w,k;if(0!==a.last_lit){do e=a.pending_buf[a.d_buf+2*l]<<8|a.pending_buf[a.d_buf+2*l+1],g=a.pending_buf[a.l_buf+l],l++,0===e?f(a,g,c):(w=C[g],f(a,w+256+1,c),k=t[w],0!==k&&(g-=b[w],h(a,g,k)),e--,w=256>e?v[e]:v[256+(e>>>7)],f(a,w,d),k=y[w],0!==k&&(e-=I[w],
h(a,e,k)));while(l<a.last_lit)}f(a,256,c)}function A(a,b){var c=b.dyn_tree,d=b.stat_desc.static_tree,f=b.stat_desc.has_stree,e=b.stat_desc.elems,g,h=-1,k;a.heap_len=0;a.heap_max=573;for(g=0;g<e;g++)0!==c[2*g]?(a.heap[++a.heap_len]=h=g,a.depth[g]=0):c[2*g+1]=0;for(;2>a.heap_len;)k=a.heap[++a.heap_len]=2>h?++h:0,c[2*k]=1,a.depth[k]=0,a.opt_len--,f&&(a.static_len-=d[2*k+1]);b.max_code=h;for(g=a.heap_len>>1;1<=g;g--)l(a,c,g);k=e;do g=a.heap[1],a.heap[1]=a.heap[a.heap_len--],l(a,c,1),d=a.heap[1],a.heap[--a.heap_max]=
g,a.heap[--a.heap_max]=d,c[2*k]=c[2*g]+c[2*d],a.depth[k]=(a.depth[g]>=a.depth[d]?a.depth[g]:a.depth[d])+1,c[2*g+1]=c[2*d+1]=k,a.heap[1]=k++,l(a,c,1);while(2<=a.heap_len);a.heap[--a.heap_max]=a.heap[1];g=b.dyn_tree;k=b.max_code;for(var m=b.stat_desc.static_tree,n=b.stat_desc.has_stree,p=b.stat_desc.extra_bits,t=b.stat_desc.extra_base,r=b.stat_desc.max_length,s,u,v=0,e=0;15>=e;e++)a.bl_count[e]=0;g[2*a.heap[a.heap_max]+1]=0;for(d=a.heap_max+1;573>d;d++)f=a.heap[d],e=g[2*g[2*f+1]+1]+1,e>r&&(e=r,v++),
g[2*f+1]=e,f>k||(a.bl_count[e]++,s=0,f>=t&&(s=p[f-t]),u=g[2*f],a.opt_len+=u*(e+s),n&&(a.static_len+=u*(m[2*f+1]+s)));if(0!==v){do{for(e=r-1;0===a.bl_count[e];)e--;a.bl_count[e]--;a.bl_count[e+1]+=2;a.bl_count[r]--;v-=2}while(0<v);for(e=r;0!==e;e--)for(f=a.bl_count[e];0!==f;)m=a.heap[--d],m>k||(g[2*m+1]!==e&&(a.opt_len+=(e-g[2*m+1])*g[2*m],g[2*m+1]=e),f--)}q(c,h,a.bl_count)}function F(a,b,c){var d,e=-1,f,g=b[1],h=0,l=7,k=4;0===g&&(l=138,k=3);b[2*(c+1)+1]=65535;for(d=0;d<=c;d++)f=g,g=b[2*(d+1)+1],++h<
l&&f===g||(h<k?a.bl_tree[2*f]+=h:0!==f?(f!==e&&a.bl_tree[2*f]++,a.bl_tree[32]++):10>=h?a.bl_tree[34]++:a.bl_tree[36]++,h=0,e=f,0===g?(l=138,k=3):f===g?(l=6,k=3):(l=7,k=4))}function B(a,b,c){var d,e=-1,g,l=b[1],k=0,m=7,n=4;0===l&&(m=138,n=3);for(d=0;d<=c;d++)if(g=l,l=b[2*(d+1)+1],!(++k<m&&g===l)){if(k<n){do f(a,g,a.bl_tree);while(0!==--k)}else 0!==g?(g!==e&&(f(a,g,a.bl_tree),k--),f(a,16,a.bl_tree),h(a,k-3,2)):10>=k?(f(a,17,a.bl_tree),h(a,k-3,3)):(f(a,18,a.bl_tree),h(a,k-11,7));k=0;e=g;0===l?(m=138,
n=3):g===l?(m=6,n=3):(m=7,n=4)}}function G(a){var b=4093624447,c;for(c=0;31>=c;c++,b>>>=1)if(b&1&&0!==a.dyn_ltree[2*c])return 0;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return 1;for(c=32;256>c;c++)if(0!==a.dyn_ltree[2*c])return 1;return 0}function D(a,b,c,d){h(a,0+(d?1:0),3);g(a);m(a,c);m(a,~c);s.arraySet(a.pending_buf,a.window,b,c,a.pending);a.pending+=c}var s=d("../utils/common"),t=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],y=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,
6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],u=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],H=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],r=Array(576);k(r);var a=Array(60);k(a);var v=Array(512);k(v);var C=Array(256);k(C);var b=Array(29);k(b);var I=Array(30);k(I);var K=function(a,b,c,d,e){this.static_tree=a;this.extra_bits=b;this.extra_base=c;this.elems=d;this.max_length=e;this.has_stree=a&&a.length},z,N,O,L=function(a,b){this.dyn_tree=a;this.max_code=0;this.stat_desc=b},P=!1;e._tr_init=function(d){if(!P){var e,
f,g,h=Array(16);for(g=f=0;28>g;g++)for(b[g]=f,e=0;e<1<<t[g];e++)C[f++]=g;C[f-1]=g;for(g=f=0;16>g;g++)for(I[g]=f,e=0;e<1<<y[g];e++)v[f++]=g;for(f>>=7;30>g;g++)for(I[g]=f<<7,e=0;e<1<<y[g]-7;e++)v[256+f++]=g;for(e=0;15>=e;e++)h[e]=0;for(e=0;143>=e;)r[2*e+1]=8,e++,h[8]++;for(;255>=e;)r[2*e+1]=9,e++,h[9]++;for(;279>=e;)r[2*e+1]=7,e++,h[7]++;for(;287>=e;)r[2*e+1]=8,e++,h[8]++;q(r,287,h);for(e=0;30>e;e++)a[2*e+1]=5,a[2*e]=c(e,5);z=new K(r,t,257,286,15);N=new K(a,y,0,30,15);O=new K([],u,0,19,7);P=!0}d.l_desc=
new L(d.dyn_ltree,z);d.d_desc=new L(d.dyn_dtree,N);d.bl_desc=new L(d.bl_tree,O);d.bi_buf=0;d.bi_valid=0;n(d)};e._tr_stored_block=D;e._tr_flush_block=function(b,c,d,e){var f,l,k=0;if(0<b.level){2===b.strm.data_type&&(b.strm.data_type=G(b));A(b,b.l_desc);A(b,b.d_desc);F(b,b.dyn_ltree,b.l_desc.max_code);F(b,b.dyn_dtree,b.d_desc.max_code);A(b,b.bl_desc);for(k=18;3<=k&&0===b.bl_tree[2*H[k]+1];k--);b.opt_len+=3*(k+1)+14;f=b.opt_len+3+7>>>3;l=b.static_len+3+7>>>3;l<=f&&(f=l)}else f=l=d+5;if(d+4<=f&&-1!==
c)D(b,c,d,e);else if(4===b.strategy||l===f)h(b,2+(e?1:0),3),E(b,r,a);else{h(b,4+(e?1:0),3);c=b.l_desc.max_code+1;d=b.d_desc.max_code+1;k+=1;h(b,c-257,5);h(b,d-1,5);h(b,k-4,4);for(f=0;f<k;f++)h(b,b.bl_tree[2*H[f]+1],3);B(b,b.dyn_ltree,c-1);B(b,b.dyn_dtree,d-1);E(b,b.dyn_ltree,b.dyn_dtree)}n(b);e&&g(b)};e._tr_tally=function(a,b,c){a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255;a.pending_buf[a.d_buf+2*a.last_lit+1]=b&255;a.pending_buf[a.l_buf+a.last_lit]=c&255;a.last_lit++;0===b?a.dyn_ltree[2*c]++:(a.matches++,
b--,a.dyn_ltree[2*(C[c]+256+1)]++,a.dyn_dtree[2*(256>b?v[b]:v[256+(b>>>7)])]++);return a.last_lit===a.lit_bufsize-1};e._tr_align=function(a){h(a,2,3);f(a,256,r);16===a.bi_valid?(m(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):8<=a.bi_valid&&(a.pending_buf[a.pending++]=a.bi_buf&255,a.bi_buf>>=8,a.bi_valid-=8)}},{"../utils/common":2}],9:[function(d,p,e){p.exports=function(){this.input=null;this.total_in=this.avail_in=this.next_in=0;this.output=null;this.total_out=this.avail_out=this.next_out=0;this.msg="";this.state=
null;this.data_type=2;this.adler=0}},{}]},{},[1])(1)});this.deflate=function(J){return z.deflate(J,{level:8})}};


/** Responsible for transfering messages between Classes, Clinet->Engine and Engine->Client communication
 * If your module wants to operate messages it should depend on {@link module:engine/communication} module.
 * In order to send messages extend or create {@link MessageSenderMixin} using {@link engine.communication.factory}
 * In order to recieve messages extend or create {@link MessageRecieverMixin} using {@link engine.communication.factory}
 * <b>Do not use</b> engine.communicatation.controller directly
 * Subject and Topics for different components can be found in {@link MESSAGING_DATA}
 * @module engine/communication*/
(function() {
    function Component() {
        ComponentInterface.call(this);
        var commonCommunication = new CommunicationComponent(engine);

        this.create = function(config) {
            /* setup connection between client/engine contexts */
            commonCommunication.create(config);
            if (engine.externalCommunicator) {
                engine.communication.controller.setTransmitter(engine.externalCommunicator);
                engine.externalCommunicator.setTransmitter(engine.communication.controller);
            }
        }
    }

    engine.addComponent("engine/communication", ["engine/logging"], new Component());
})();


function ConfigComponent(context) {
    ComponentInterface.call(this);

    var services = [
        SETTINGS.DCM_CONFIG_NAME,
        SETTINGS.PII_CONFIG_NAME,
        SETTINGS.FILTERS_CONFIG_NAME,
        SETTINGS.WHITELIST_CONFIG_NAME
    ];

    var listeners = [];

    this.create = function(config) {
        var logger = context.loggerFactory.getLogger("ConfigComponent");

        logger.info("creating ConfigComponent");
        services.forEach(function(service) {

            listeners.push(new ConfigVersionProvider(context, service));
            listeners.push(new ConfigStatusReporter(context, service));

            logger.info("creating " + service + " ...");
        });
    };

    this.destroy = function() {};
}

engine.addComponent("engine/config",
    ["engine/userInfo", "engine/caching", "engine/diagnostic"], new ConfigComponent(engine));


function ConfigStatusReporter(context, configName) {
    CachingListener.call(this, configName);

    var diagnosticSender = context.diagnostic.sender;

    var settings = context.storageFactory.getSettings();
    var currentVersion = settings.get(configName + "." + SETTINGS.VERSION);
    var logger = context.loggerFactory.getLogger("ConfigStatusReporter[" + configName + "]");

    this.onConfigAvailable = function(cachingConfig) {
        var msg = "";
        var newVersion = cachingConfig.getVersion();

        if (currentVersion) {
            if (currentVersion != newVersion) {
                msg = "'" + configName + "' config has been updated from version '" +
                      currentVersion + "' to version '" + newVersion + "'.";
                diagnosticSender.sendEvent("dcm-engine-cached-config", msg);
            } else {
                msg = "'" + configName + "' config with version '" + currentVersion + "' is available.";
                diagnosticSender.sendEvent("dcm-engine-cached-config", msg);
            }
        } else {
            msg = "New '" + configName + "' config with version '" + newVersion + "' has been cached.";
            diagnosticSender.sendEvent("dcm-engine-cached-config", msg);
        }

        currentVersion = newVersion;
    };

    this.onConfigRemoved = function() {
        var msg = "";
        if (currentVersion) {
            msg = "'" + configName + "' config with version '" + currentVersion +"' has been removed.";
            diagnosticSender.sendEvent("dcm-engine-removed-config", msg);
        } else {
            msg = "'" + configName + "' config is not available.";
            diagnosticSender.sendEvent("dcm-engine-removed-config", msg);
        }

        currentVersion = null;
    }
}


/** Listen to the version of caching configurations and stores this data in the preferences
 * @param {DCMContext} context
 * @param {String} configName
 * @extends CachingListener
 * @constructor */
function ConfigVersionProvider(context, configName) {
    CachingListener.call(this, configName);

    var settings = context.storageFactory.getSettings();
    var versionName = configName + "." + SETTINGS.VERSION;

    this.onConfigAvailable = function(cachingConfig) {
        settings.set(versionName, cachingConfig.getVersion());
    };

    this.onConfigRemoved = function() {
        settings.remove(versionName);
    }
}

/** Interface of the class which able to construct caching service for some component
 * @interface
 * @constructor */
function CachingComponentBuilderInterface() {
    /** build caching service for the component
     * @param {CachingConfig} config of the service
     * @return {CachingService}*/
    this.buildCachingService = function(config) {};

    /** build caching config for the service or null in case config not available
     * @param {DcmConfig} dcmConfig from which service data should be built
     * @return {CachingConfig|null}*/
    this.buildCachingConfig = function(dcmConfig) {};
}


/** Parser of the Dcm configuration file. No data validation performed
 * @extends ComponentDataParser
 * @constructor */
function DcmComponentDataParser() {
    ComponentDataParser.call(this);

    this.parseJsonData = function(json) {
        return new DcmConfig(json);
    }
}

/** Dcm Configuration object
 * @param {Object} json instance of config data
 * @extends ComponentData
 * @constructor*/
function DcmConfig(json) {
    ComponentData.call(this, json);

    function parseCachingConfig(cachingData) {
        if (cachingData && cachingData.url && cachingData.downloadIntervalMinutes) {
            return new CachingConfig(
                cachingData.url,
                cachingData.downloadIntervalMinutes,
                cachingData.maxFailedAttempts);
        }

        return null;
    }

    /** Check if DCM could send Request Data.
     * @returns {Boolean}*/
    this.isDataDisabled = function() {
        return (json.dataSending && !!json.dataSending.disabled)
    };

    this.isCompressionEnabled = function() {
        return json.dataSending.compressData === undefined || json.dataSending.compressData;
    };

    /** Check whether DCM should discard sending of post data and parameters values for clicks
     * @return {Boolean} */
    this.isPostDataAndParametersDiscarded = function() {
        return (json.dataSending && !!json.dataSending.discardPostDataAndParameters);
    };

    /** Get maximum size of data that should be sent in bytes (symbols)
     * @return {Number}*/
    this.getBatchMaxSize = function() {
        var batchSizeKBytes = json.dataSending.batchSizeKBytes;
        if (batchSizeKBytes === undefined) {
            batchSizeKBytes = 50;
        }
        return batchSizeKBytes * 1024;
    };

    /** Get maximum wait time when batch is sent*/
    this.getBatchMaxWait = function() {
        var batchMaxWaitSeconds = json.dataSending.batchMaxWaitSeconds;
        if (!batchMaxWaitSeconds) {
            batchMaxWaitSeconds = 5;
        }
        return batchMaxWaitSeconds * 1000;
    };

    /** Return configuration block for diagnostic data
     * @return {CachingConfig}*/
    this.getPingData = function() {
        if (json.diagnostic) {
            return parseCachingConfig(json.diagnostic.ping);
        }

        return null;
    };

    /** Return privacy filter configuration block
      * @returns {CachingConfig} */
    this.getPiiData = function() {
        return parseCachingConfig(json.piiService);
    };

    /** Returns domain black list configuration block
     * @return {CachingConfig} */
    this.getFiltersData = function() {
        return parseCachingConfig(json.filtersService);
    };

    /** Returns whitelist configuration block
     * @returns {CachingConfig}
     */
    this.getWhitelistData = function() {
        return parseCachingConfig(json.whitelistService);
    };

    this.getOptInData = function() {
        return json.optIn;
    }
}

function DcmConfigComponent(context) {
    ComponentInterface.call(this);

    var service;
    var dialogProvider;

    var downloadInterval = 15; //minutes
    var maxFailedAttempts = 96; // 24 hours

    this.create = function(config) {
        var cachingConfig = new CachingConfig(
            SETTINGS.DCM_CONFIG_URL,
            downloadInterval,
            maxFailedAttempts);

        cachingConfig.setName(SETTINGS.DCM_CONFIG_NAME);

        dialogProvider = new DcmConfigDialogProvider(context);

        service = new CachingFactory(context)
            .buildService(cachingConfig)
            .withParser(new DcmComponentDataParser())
            .withDefaultStorage()
            .withDefaultStatusReporter()
            .withDefaultDownloader()
            .finalize();

        service.start();
    };

    this.destroy = function() {
        dialogProvider.unregister();
        dialogProvider = null;

        service.stop();
        service = null;
    }
}

engine.addComponent("engine/config/dcm", ["engine/config", "engine/caching", "engine/diagnostic"],
    new DcmConfigComponent(engine));

function DcmConfigDialogProvider(context) {
    CachingListener.call(this, SETTINGS.DCM_CONFIG_NAME);
    var sender = context.communication.factory.createSender();

    this.onConfigAvailable = function(cachingConfig) {
        sender.transmit(MESSAGING_DATA.OPT_IN_DIALOG_SUBJECT, MESSAGING_DATA.OPT_IN_DIALOG_CONFIG_AVAILABLE,
            cachingConfig.getOptInData() ? cachingConfig.getOptInData() : {});
    };

    this.onConfigRemoved = function() {
        sender.transmit(MESSAGING_DATA.OPT_IN_DIALOG_SUBJECT, MESSAGING_DATA.OPT_IN_DIALOG_CONFIG_REMOVED);
    }
}

/** Class which allow to startup/shutdown Caching Service accordingly to data available in DCM config.
 * Service will be started as only component builder will provide {@link CachingConfig}.
 * Service will be restarted when new DCM config is downloaded and service config exist
 * Service will be stopped when DCM config is not available or service config missing.
 * Owner of this class should stop it manually on Application stop.
 * @param {CachingComponentBuilderInterface} cachingComponentBuilder which constructs service and config
 * @extends CachingListener
 * @constructor*/
function DcmDependentController(cachingComponentBuilder) {
    CachingListener.call(this, SETTINGS.DCM_CONFIG_NAME);
    var service;

    function startService(config) {
        service = cachingComponentBuilder.buildCachingService(config);
        service.start();
    }

    function stopService() {
        if (service) {
            service.stop();
            service = null;
        }
    }

    /** Stop controller*/
    this.stop = function() {
        stopService();
    };

    this.onConfigAvailable = function(dcmConfig) {
        stopService();
        var cachingConfig = cachingComponentBuilder.buildCachingConfig(dcmConfig);
        if (cachingConfig) {
            startService(cachingConfig);
        }
    };

    this.onConfigRemoved = function() {
        stopService();
    }
}

/** Allows to specify default config that would be used when DCM Config is unavailable
 * @param {CachingComponentBuilderInterface} cachingComponentBuilder which constructs service and config
 * @constructor
 * @extends DcmDependentController */
function DefaultDcmDependentController(cachingComponentBuilder) {
    DcmDependentController.call(this, cachingComponentBuilder);

    this.onConfigRemoved = function() {
        this.onConfigAvailable(new DcmConfig({}));
    };
}

(function() {
    function Component() {
        ComponentInterface.call(this);

        var service;

        this.create = function() {
            var defaultConfig = new CachingConfig(SETTINGS.FILTERS_CONFIG_URL, 1440);
            var componentBuilder = new FiltersComponentBuilder(engine, defaultConfig);

            service = new DefaultDcmDependentController(componentBuilder);
        };

        this.destroy = function() {
            service.stop();
        };
    }

    engine.addComponent("engine/config/filters", ["engine/config/dcm", "engine/diagnostic"], new Component());
})();


/** Class to construct Filters Caching Service from dcm Config
 * @param {DCMContext} context
 * @param {CachingConfig} defaultConfig
 * @extends CachingComponentBuilderInterface
 * @constructor */
function FiltersComponentBuilder(context, defaultConfig) {
    CachingComponentBuilderInterface.call(this);

    this.buildCachingService = function(config) {
        return new CachingFactory(context)
            .buildService(config)
            .withParser(new FiltersDataParser())
            .withDefaultStorage()
            .withDefaultDownloader()
            .withDefaultStatusReporter()
            .finalize();
    };

    this.buildCachingConfig = function(dcmConfig) {
        var cachingConfig = dcmConfig.getFiltersData();

        if (cachingConfig == null) {
            cachingConfig = defaultConfig;
        }

        cachingConfig.setName(SETTINGS.FILTERS_CONFIG_NAME);

        return cachingConfig;
    };
}

/** Wrapper for Filters Config
 * @param json
 * @constructor */
function FiltersConfig(json) {
    ComponentData.call(this, json);

    this.getDomains = function() {
        return json.domains;
    };

    this.getUrls = function() {
        return json.urls;
    }
}


/**
 * Parser for Filters config
 * @constructor
 */
function FiltersDataParser() {
    ComponentDataParser.call(this);

    this.parseJsonData = function(json) {
        return new FiltersConfig(json);
    }
}


function PiiComponent(context) {
    ComponentInterface.call(this);

    var piiService;

    this.create = function() {
        var componentBuilder = new PiiComponentBuilder(context);
        piiService = new DcmDependentController(componentBuilder);
    };

    this.destroy = function() {
        piiService.stop();
        piiService = null;
    };
}

engine.addComponent("engine/config/pii", ["engine/config/dcm", "engine/diagnostic"],
    new PiiComponent(engine));

/** Class to construct Pii Caching Service from dcm Config
 * @extends CachingComponentBuilderInterface
 * @constructor */
function PiiComponentBuilder(context) {
    CachingComponentBuilderInterface.call(this);

    this.buildCachingService = function(config) {
        return new CachingFactory(context)
            .buildService(config)
            .withParser(new PiiComponentDataParser())
            .withDefaultStorage()
            .withDefaultDownloader()
            .withDefaultStatusReporter()
            .finalize();
    };

    this.buildCachingConfig = function(config) {
        var cachingConfig = config.getPiiData();
        if (cachingConfig) {
            cachingConfig.setName(SETTINGS.PII_CONFIG_NAME);
            return cachingConfig;
        }

        return null;
    };
}

/** Parser of the Privacy filter configuration file. No data validation performed yet
 * @extends ComponentDataParser
 * @constructor */
function PiiComponentDataParser() {
    ComponentDataParser.call(this);

    this.parseJsonData = function(json) {
        return new PiiConfig(json);
    }
}

/** Privacy Information Filter config object
 * @param {Object} json instance of config data
 * @extends ComponentData
 * @constructor*/
function PiiConfig(json) {
    ComponentData.call(this, json);

    /** Return filters for clicks filtering
     * @return {Object} */
    this.getFilters = function() {
        return json.filters;
    }
}

function WhitelistDataParser() {
    ComponentDataParser.call(this);

    this.parseJsonData = function(json) {
        return new WhitelistConfig(json);
    };
}


function WhitelistCachingBuilder(context) {
    CachingComponentBuilderInterface.call(this);

    this.buildCachingService = function(config) {
        return new CachingFactory(context)
            .buildService(config)
            .withParser(new WhitelistDataParser())
            .withDefaultStorage()
            .withDefaultDownloader()
            .withDefaultStatusReporter()
            .finalize();
    };

    this.buildCachingConfig = function(dcmConfig) {
        var cachingConfig = dcmConfig.getWhitelistData();
        if (cachingConfig) {
            cachingConfig.setName(SETTINGS.WHITELIST_CONFIG_NAME);
            return cachingConfig;
        }

        return null;
    };
}


function WhitelistComponent(context) {
    ComponentInterface.call(this);

    var service;

    this.create = function(config) {
        service = new DcmDependentController(new WhitelistCachingBuilder(context));
    };

    this.destroy = function() {
        service.stop();
        service = null;
    };
}

engine.addComponent("engine/config/whitelist", ["engine/config/dcm", "engine/diagnostic"],
    new WhitelistComponent(engine));


function WhitelistConfig(json) {
    ComponentData.call(this, json);

    this.getHttpsConfig = function() {
        return json.https;
    }
}


function DiagnosticComponent(context) {
    ComponentInterface.call(this);

    this.create = function(config) {
        context.diagnostic = {};
        context.diagnostic.sender = new DiagnosticEventSender(context);
        context.diagnostic.requestsDiagnostic = new RequestsDiagnostic(context);
    };
}

engine.addComponent("engine/diagnostic",
    ["engine/xhr", "engine/logging"], new DiagnosticComponent(engine));

/** Responsible for sending diagnostic events.
 * @param {DCMContext} context
 * @extends {CachingListener}
 * @constructor */
function DiagnosticEventSender(context) {
    var logger = context.loggerFactory.getLogger("diagnostic.DiagnosticEventSender");
    var settings = context.storageFactory.getSettings();

    function getOffset() {
        var offset = parseInt(settings.get(SETTINGS.EPOCH_OFFSET));
        return isNaN(offset) ? 0 : offset;
    }

    function formatMessage(message) {
        var updatedMsg = message ? message + " " : "";
        return updatedMsg + "Engine instance id = " + context.instanceId + ".";
    }

    function createJson(eventType, message) {
        return {
            event: eventType,
            timestamp: Date.now() - getOffset(),
            message: formatMessage(message)
        };
    }

    /** Sends the diagnostic event
     * @param {String} eventType Name of the event
     * @param {String} [message] String message that contains detailed description of the event */
     this.sendEvent = function(eventType, message) {
         logger.info("Sending event: " + eventType + "; message: " + message);

         var xhr = context.requestFactory.createPost(SETTINGS.DIAGNOSTIC_URL, function(){});
         var json = createJson(eventType, message);
         xhr.send(JSON.stringify(json));
    };


    /** Sends the diagnostic event along with additional data
     * @param {String} eventType Name of the event
     * @param {Object} data. The data will be added as a values field
     * @param {String} url
     * @param {Function} callback */
    this.sendEventEx = function(eventType, data, url, callback) {
        var xhr = context.requestFactory.createPost(url, callback);
        var json = createJson(eventType);

        json.values = data;
        xhr.send(JSON.stringify(json));
    }
}

/** Class to build ping caching service
 * @param {CachingConfig} defaultConfig
 * @extends CachingComponentBuilderInterface
 * @constructor*/
function PingCachingComponentBuilder(defaultConfig) {
    CachingComponentBuilderInterface.call(this);

    this.buildCachingService = function(config) {
        var downloader = new PingCachingDownloader();
        var storage = new PingCachingStorage();
        return new CachingFactory(engine)
            .buildService(config)
            .withDefaultParser()
            .withDownloader(downloader)
            .withStorage(storage)
            .finalize();
    };

    this.buildCachingConfig = function(dcmConfig) {
        var cachingConfig = dcmConfig.getPingData();

        if (cachingConfig == null) {
            cachingConfig = defaultConfig;
        }

        cachingConfig.setName("ping");

        return cachingConfig;
    };
}

/** Performs ping request. Used as CacheDownloader in CachingService
 * @constructor */
function PingCachingDownloader() {
    /** Download config file
     * @param {String} url to be downloaded from
     * @param {Function} callback to be called after response is received */
    this.download = function(url, callback) {
        var settings = engine.storageFactory.getSettings();
        var all = settings.getAll();

        engine.diagnostic.sender.sendEventEx("dcm-ping", all, url, callback);
    };
}

/** Dummy implementation of caching storage used in Ping service
 * @constructor
 * @extends {CachingStorageInterface} */
function PingCachingStorage() {
    CachingStorageInterface.call(this);

    this.save = function(rawData, callback) {
        callback({});
    };

    this.read = function(callback) {
        callback({});
    };
}

function PingComponent() {
    ComponentInterface.call(this);

    var ping;

    this.create = function() {
        var defaultConfig = new CachingConfig(SETTINGS.DIAGNOSTIC_URL, 1440);
        var componentBuilder = new PingCachingComponentBuilder(defaultConfig);
        ping = new DefaultDcmDependentController(componentBuilder);
    };

    this.destroy = function() {
        ping.stop();
        ping = null;
    };
}

engine.addComponent("engine/diagnostic/ping", ["engine/diagnostic"], new PingComponent());

function RequestsDiagnostic(context) {

    var sender = context.diagnostic.sender;

    /** Sending diagnostic event notifying that request is about to be made
     * @param {String} url
     */
    this.onBeforeSend = function(url) {
        sender.sendEvent("dcm-engine-request", "Making request to '" + url + "'.");
    };

    /** Sending diagnostic event notifying that response for particular request was received
     * @param {String} url
     * @param {XhrResponse} response
     */
    this.onAfterSend = function(url, response) {
        sender.sendEvent("dcm-engine-request",
                "Received '" + response.getCode() + "' response from '" + url + "'.");
    }
}


/** Manages lifetime of Epoch Time Service
 * @param {DCMContext} context
 * @extends {ComponentInterface}
 * @constructor */
function EpochComponent(context) {
    ComponentInterface.call(this);

    var epochService;

    this.create = function() {
        var cachingConfig = new CachingConfig(SETTINGS.EPOCH_CONFIG_URL, 1440);
        cachingConfig.setName(SETTINGS.EPOCH_CONFIG_NAME);

        context.caching.epochtimeProvider = new EpochTimeProvider(SETTINGS.EPOCH_CONFIG_NAME);

        var storage = new EpochStorage(new EpochDataParser());
        epochService = new CachingFactory(context)
            .buildService(cachingConfig)
            .withDefaultParser()
            .withStorage(storage)
            .withDefaultDownloader()
            .finalize();
        epochService.start();
    };

    this.destroy = function() {
        context.caching.epochtimeProvider.unregister();
        context.caching.epochtimeProvider = null;

        epochService.stop();
        epochService = null;
    };
}

engine.addComponent("engine/epoch", ["engine/caching"], new EpochComponent(engine));

/** Epoch configuration object
 * @param {Number} theOffset
 * @constructor */
function EpochConfig(theOffset) {
    ComponentData.call(this, {name: "epoch"});
    var offset = isNaN(theOffset) ? 0 : parseInt(theOffset);

    /** Returns the current offset
     * @return {Number} */
    this.getOffset = function() {
        return offset;
    }
}

/** Parses response from NTP online service
 * @extends {ComponentDataParser}
 * @constructor
 */
function EpochDataParser() {
    ComponentDataParser.call(this);
    var logger = engine.loggerFactory.getLogger("EpochDataParser");

    this.parseString = function(string) {
        var offset = 0;
        try {
            var object = engine.parsingUtils.parseJSON(string);
            if (object !== undefined && object.datetime !== undefined) {
                var serverTime = Date.parse(object.datetime);
                if (serverTime) {
                    var localTime = Math.round(Date.now() / 1000) * 1000;
                    offset = localTime - serverTime;
                }
            }
        } catch (e) {
            logger.info("Cannot parse '" + string + "'. " + e);
        }

        return offset.toString();
    }
}

/** Responsible for storing epoch offset in preferences
 * @extends {CachingStorageInterface}
 * @constructor */
function EpochStorage(parser) {
    CachingStorageInterface.call(this);

    var settings = engine.storageFactory.getSettings();
    var logger = engine.loggerFactory.getLogger("EpochStorage");

    this.save = function(rawData, callback) {
        try {
            var offset = parser.parseString(rawData);
            settings.set(SETTINGS.EPOCH_OFFSET, offset);
            callback(new EpochConfig(offset));
        } catch (e) {
            logger.debug("Cannot write cached data. " + e);
        }
    };

    this.read = function(callback) {
        try {
            if (settings.has(SETTINGS.EPOCH_OFFSET)) {
                var offset = settings.get(SETTINGS.EPOCH_OFFSET);
                callback(new EpochConfig(offset));
            } else {
                callback(null);
            }
        } catch (e) {
            logger.debug("Cannot read cached data. " + e);
        }
    };

    this.clear = function() {
        try {
            settings.remove(SETTINGS.EPOCH_OFFSET);
        } catch (e) {
            logger.debug("Cannot remove cached data. " + e);
        }
    }
}

/** Contains cached epoch offset
 * @param {String} configName
 * @constructor */
function EpochTimeProvider(configName) {
    CachingListener.call(this, configName);
    var epochConfig = null;

    this.onConfigAvailable = function(cachingConfig) {
        epochConfig = cachingConfig;
    };

    this.onConfigRemoved = function() {
        epochConfig = null;
    };

    /** Calculate new time stamp according to epoch offset
     * @param {Number} timestamp that should be updated
     * @return {Number} New timestamp */
    this.calculateTimestamp = function(timestamp) {
        var offset = 0;
        if (epochConfig) {
            offset = epochConfig.getOffset();
        }

        return timestamp - offset;
    }
}

function EngineStarter(worker) {
    var workerCommunicator = new WorkerCommunicator(worker);
    var acceptedMessages = {};

    function startEngine(data) {
        try {
            engine.externalCommunicator = workerCommunicator;
            engine.create(JSON.parse(data));
            workerCommunicator.receive(MESSAGING_DATA.ENGINE_WORKER_SUBJECT, MESSAGING_DATA.ENGINE_CREATED_TOPIC, null);
        } catch (e) {
            //error during creation of engine. don't send reply
        }
    }

    function stopEngine() {
        engine.destroy();
    }

    function cleanupEngine() {
        engine.cleanup();
    }

    function configureEngine(data) {
        engine.options(JSON.parse(data));
    }

    function messagesListener(topic, data) {
        var procedure = acceptedMessages[topic];
        if (procedure) {
            procedure(data);
        }
    }

    function startCommunicator() {
        acceptedMessages[MESSAGING_DATA.ENGINE_CREATE_TOPIC] = startEngine;
        acceptedMessages[MESSAGING_DATA.ENGINE_CLEANUP_TOPIC] = cleanupEngine;
        acceptedMessages[MESSAGING_DATA.ENGINE_DESTROY_TOPIC] = stopEngine;
        acceptedMessages[MESSAGING_DATA.ENGINE_OPTIONS_TOPIC] = configureEngine;
        workerCommunicator.addReceiver(MESSAGING_DATA.ENGINE_WORKER_SUBJECT, messagesListener);
        workerCommunicator.start();
    }

    startCommunicator();
}

var starter = new EngineStarter(self);

/** Component is responsible for managing engine install and update instructions
 * @constructor */
function EngineInstallComponent(context) {
    ComponentInterface.call(this);

    var settings;
    var logger;

    function performEngineInstall(engineVersion) {
        logger.info("Performing engine install procedures. Version: " + engineVersion);
        settings.set(SETTINGS.ENGINE_VERSION, engineVersion);

        context.diagnostic.sender.sendEvent("dcm-engine-installed");
    }

    function performEngineUpdate(installedEngineVersion, newEngineVersion) {
        logger.info("Performing engine update from '" + installedEngineVersion + "' to '" + newEngineVersion + "'");
        settings.set(SETTINGS.ENGINE_VERSION, newEngineVersion);

        context.diagnostic.sender.sendEvent("dcm-engine-updated",
            "DCM Engine has been updated from '" + installedEngineVersion + "'.");
    }

    this.create = function(config) {
        logger = context.loggerFactory.getLogger("lifecycle.EngineInstallComponent");

        try {
            settings = context.storageFactory.getSettings();
            if (settings.has(SETTINGS.ENGINE_VERSION)) {
                var installedEngineVersion = settings.get(SETTINGS.ENGINE_VERSION);

                if (isUpdate(installedEngineVersion, config.engineVersion)) {
                    performEngineUpdate(installedEngineVersion, config.engineVersion);
                }
            } else {
                performEngineInstall(config.engineVersion);
            }

        } catch (e) {
            logger.error("Error during install procedures: " + e);
        }
    }
}

engine.addComponent("engine/install",
    ["engine/storage", "engine/logging", "engine/diagnostic", "engine/version"],
    new EngineInstallComponent(engine));


/** Package which manages install/update/uninstall procedures.
 * @param {DCMContext} context
 * @constructor
*/
function LifecycleComponent(context) {
    ComponentInterface.call(this);

    this.create = function(config) {
        context.diagnostic.sender.sendEvent("dcm-engine-started");
    };

}
engine.addComponent("engine/lifecycle", ["engine/install"], new LifecycleComponent(engine));



/** Initializes config with engineVersion field.
 * @extends ComponentInterface
 * @constructor */
function VersionComponent() {
    ComponentInterface.call(this);

    this.create = function(config) {
        config.engineVersion = "1.2.186";
    };
}

engine.addComponent("engine/version", [], new VersionComponent());

/** Engine side logging functionality for debug purposes
 * In order to use logger your module should depend on {@link module:engine/logging} module
 * Use engine.loggerFactory to create logger for your class
 * @module engine/logging
*/
(function() {
    function EngineLoggerFactory() {
        this.getLogger = function(className) {
            return new EngineLogger(className);
        }
    }

    function Component(context) {
        ComponentInterface.call(this);
        this.create = function(config) {
            /** Instance of loggerFactory to use
             * @memberOf engine
             * @type LoggerFactoryInterface */
            context.loggerFactory = new EngineLoggerFactory();
        };
    }

    engine.addComponent("engine/logging", [], new Component(engine));
})();


/** Engine logger class. Transports all messages via communication to the client for disk logging.
 * Create instace only via {@link engine.loggerFactory}
 * @param {String} className of the logger
 * @extends LoggerInterface
 * @constructor*/
function EngineLogger(className) {
    LoggerInterface.call(this);
    var sender;
    var initialized = false;

    function initializeSender() {
        if (!initialized && engine.communication) {
            try {
                sender = engine.communication.factory.createSender();
                initialized = true;
            } catch (e) {
                //unable to initialize communication not ready;
            }
        }
        return initialized;
    }

    this.sendLogMessage = function(level, data) {
        if (initializeSender()) {
            sender.transmit(MESSAGING_DATA.APPLICATION_LOG_SUBJECT, className+":"+level, data);
        }
    };

    this.debug = function(message) {
        this.sendLogMessage("debug", message);
    };

    this.info = function(message) {
        this.sendLogMessage("info", message);
    };

    this.warn = function(message) {
        this.sendLogMessage("warn", message);
    };

    this.error = function(message) {
        this.sendLogMessage("error", message);
    }
}

function ConfirmationPageLoader(context) {
    CachingListener.call(this, SETTINGS.DCM_CONFIG_NAME);

    var settings = context.storageFactory.getSettings();
    var logger = context.loggerFactory.getLogger("ConfirmationPageLoader");

    function openUrl(url) {
        var urlWrapper = new Url(url);

        var params = urlWrapper.getParams();

        if (settings.has(SETTINGS.USER_ID)) {
            params["userId"] = settings.get(SETTINGS.USER_ID);
        }

        urlWrapper.setParams(params);

        context.browser.component.openUrl(urlWrapper.toString());
    }

    var userInfo = context.config.userInfo;

    function showPage(url) {
        if (!userInfo.isDataCapturingDisabled() && !userInfo.wasConfirmationPageShown()) {
            settings.set(SETTINGS.CONFIRMATION_PAGE_SHOWN, true);
            userInfo.setConfirmationPageShown(true);

            openUrl(url);

            logger.debug("User is going to be redirected to: " + url);
        } else {
            logger.debug("User is not going to be redirected to: " + url +
                         " since either data capturing disabled is true or confirmation page was shown");
        }
    }

    this.onConfigAvailable = function(cachingConfig) {
        var optIn = cachingConfig.getOptInData();
        if (optIn && optIn.acceptPageUrl && optIn.acceptPageUrl.length > 0) {
            showPage(optIn.acceptPageUrl);
        }
    };
}


function OptInComponentRegistration(context) {
    ComponentInterface.call(this);

    var pageLoader;

    this.create = function(config) {
        pageLoader = new ConfirmationPageLoader(context)
    };
}

engine.addComponent("engine/optin", ["engine/config/dcm",
                                     "engine/logging",
                                     "engine/config",
                                     "engine/browser"], new OptInComponentRegistration(engine));


(function() {
    function Component() {
        ComponentInterface.call(this);

        this.create = function(config) {
            engine.storageFactory = new EngineStorageFactory(config.settingsDump);
        };
    }

    engine.addComponent("engine/storage", ["engine/communication"], new Component());
})();


/** Engine Settings Storage.
 * Uses initial dump of settings and transfers all changes call to the Remote Settings
 * @param {Object} settings snapshot
 * @param {SettingsInterface} remote version of settings
 * @extends SettingsInterface
 * @constructor */
function EngineSettingsStorage(settings, remote) {
    SettingsInterface.call(this);

    this.set = function(key, value) {
        settings[key] = value;
        remote.set(key, value);
    };

    this.get = function(key) {
        return settings[key];
    };

    this.has = function(key) {
        return settings[key] !== undefined;
    };

    this.remove = function(key) {
        delete settings[key];
        remote.remove(key);
    };

    this.removeAll = function() {
        settings = {};
        remote.removeAll();
    };

    this.getAll = function() {
        return settings;
    };
}

function EngineStorageFactory(settings) {
    var settingsStorage;

    this.getStorage = function(name) {
        return new RemoteStorageSource(name);
    };

    this.getSettings = function() {
        if (!settingsStorage) {
            var remote = new RemoteSettingsStorageSource();
            settingsStorage = new EngineSettingsStorage(settings, remote)
        }
        return settingsStorage;
    }
}

/** Remote settings storage source. Transfers all calls to the target
 * @extends RemoteSettingsInterface
 * @extends RemoteObjectSource
 * @constructor*/
function RemoteSettingsStorageSource() {
    RemoteSettingsInterface.call(this);
    engine.communication.remote.extendRemoteObjectSource(this, arguments);
}

/** Remote storage source. Transfers all calls to the target
 * @extends RemoteStorageInterface
 * @extends RemoteObjectSource
 * @constructor*/
function RemoteStorageSource() {
    RemoteStorageInterface.call(this);
    engine.communication.remote.extendRemoteObjectSource(this, arguments);
}

/** Provide access to general info about user and current dcm instance.
 * Instance can be retrieved from: {@link engine.config.userInfo}
 * @constructor
 */
function UserInfo(context) {
    var settings = context.storageFactory.getSettings();
    var dataCapturingDisabled = settings.get(SETTINGS.DATA_DISABLED_KEY);
    var confirmationPageShown = settings.get(SETTINGS.CONFIRMATION_PAGE_SHOWN);

    /** Returns if user opted-out from data capturing
     * @return {Boolean}*/
    this.isDataCapturingDisabled = function() {
        return dataCapturingDisabled;
    };

    /** Sets data capturing status
     * @param {Boolean} isDisabled */
    this.setIsDataCapturingDisabled = function(isDisabled) {
        if (isDisabled !== undefined) {
            dataCapturingDisabled = isDisabled;
        }
    };

    /** Returns confirmation page shown status
     * @returns {Boolean} */
    this.wasConfirmationPageShown = function() {
        return confirmationPageShown;
    };

    /** Sets confirmation page shown status
     * @param {Boolean} wasShown */
    this.setConfirmationPageShown = function(wasShown) {
        if (wasShown !== undefined) {
            confirmationPageShown = wasShown;
        }
    }
}


function UserInfoComponent(context) {
    ComponentInterface.call(this);

    this.create = function (config) {
        context.config = {};
        context.config.userInfo = new UserInfo(engine);
    };

    this.options = function(options) {
        if (options) {
            context.config.userInfo.setIsDataCapturingDisabled(options.dataCapturingDisabled);
            context.config.userInfo.setConfirmationPageShown(options.confirmation_page_shown);
        }
    }
}

engine.addComponent("engine/userInfo",
    ["engine/storage", "engine/lifecycle"], new UserInfoComponent(engine));

var Base64 = {

    encode : function (input) {
        var b64chars
            = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

        var cb_encode = function(ccc) {
            var padlen = [0, 2, 1][ccc.length % 3],
                ord = ccc.charCodeAt(0) << 16
                    | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
                    | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
                chars = [
                    b64chars.charAt( ord >>> 18),
                    b64chars.charAt((ord >>> 12) & 63),
                    padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
                    padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
                ];
            return chars.join('');
        };

        return input.replace(/[\s\S]{1,3}/g, cb_encode);
    }
};


/** Utils methods used across the system
 * @module engine/utils
 * @param {DCMContext} context
 * @extends ComponentInterface
 * @constructor */
function UtilsComponent(context) {
    ComponentInterface.call(this);

    this.create = function() {
        context.parsingUtils = new ParsingUtils();
        context.systemUtils = new SystemUtils(context);
    }
}

engine.addComponent("engine/utils", ["engine/storage", "engine/logging"], new UtilsComponent(engine));

var DecodeUtils = {
    decodeHtmlEntity: function(str) {
        return str.replace(/&#(\d+);/g, function(match, dec) {
            return String.fromCharCode(dec);
        });
    }

//    ,encodeHtmlEntity: function(str) {
//        var buf = [];
//        for(var i = str.length - 1; i >= 0; i--) {
//            buf.unshift(['&#', str[i].charCodeAt(), ';'].join(''));
//        }
//        return buf.join('');
//    }
};


/** Schedule cycle callback execution according to timeout specified
 * @param {Number} timeout to be used
 * @constructor */
function ExecutionScheduler(timeout) {
    var timerId = null;

    function clearTimer() {
        if (timerId) {
            clearInterval(timerId);
        }
    }

    /** Schedules new callback for execution
     * @param {Function} callback to be called after timeout passed */
    this.schedule = function(callback) {
        clearTimer();
        timerId = setInterval(callback, timeout);
    };

    /** Stops the timer and cancels callback execution */
    this.clear = function() {
        clearTimer();
    };
}

/** Parsing utilities to work with JSON and other formats
* @constructor */
function ParsingUtils() {
    /** Parse string into JSON object
     * @param {String} string data to parse
     * @return {JSON} JSON object*/
    this.parseJSON = function(string) {
        return JSON.parse(string);
    };

    /** Serialize JSON object into string
     * @param {Object} object to serialize
     * @return {String} String representation */
    this.serializeJSON = function(object) {
        return JSON.stringify(object);
    };
}

/** Manages information about system (e.g. local ip address)
 * @param {DCMContext} context
 * @extends MessageRecieverMixin
 * @constructor
 */
function SystemUtils(context) {
    context.communication.factory.extendReciever(this, MESSAGING_DATA.SYSTEM_INFO_SUBJECT);

    var logger = context.loggerFactory.getLogger("engine.utils.SystemUtils");
    var settings = context.storageFactory.getSettings();
    var hasLocalAddress = settings.has(SETTINGS.LOCAL_ADDRESS);

    function storeIpAddress(data) {
        var localAddress = settings.get(SETTINGS.LOCAL_ADDRESS);
        if(localAddress) {
            localAddress += ",";
        } else {
            localAddress = "";
        }

        settings.set(SETTINGS.LOCAL_ADDRESS, localAddress + data);
    }

    this.onMessage = function(topic, data) {
        logger.info("Message received. Topic: " + topic + "; data: " + data);

        switch(topic) {
            case MESSAGING_DATA.LOCAL_IP_ADDRESS_DETECTED_TOPIC:
                if(data && !hasLocalAddress) {
                    storeIpAddress(data);
                }
                break;
        }

    };
}


/** Performs communication with outer world
 * @module engine/xhr
 */
function XhrComponent(context) {
    ComponentInterface.call(this);

    this.create = function(config) {
        context.requestFactory = new EngineXhrFactory(context);
    }
}

engine.addComponent("engine/xhr", ["engine/storage", "engine/communication"], new XhrComponent(engine));

/** Creates XMLHttpRequests.
 * @extends XhrFactoryInterface
 * @param {DCMContext} context
 * @constructor
 */
function EngineXhrFactory(context) {
    XhrFactoryInterface.call(this);

    function emptyCallback() {}

    function verifyCallback(callback) {
        if (callback) {
            return callback;
        } else {
            return emptyCallback;
        }
    }

    this.createGet = function(url, callback) {
        var executor = new XhrEngineExecutor(url, verifyCallback(callback), "GET");
        return new XhrExecutorDecorator(context, executor);
    };

    this.createPost = function(url, callback) {
        var executor = new XhrEngineExecutor(url, verifyCallback(callback), "POST");
        return new XhrExecutorDecorator(context, executor);
    };
}



/** Adapter of {@link XhrExecutorInterface} that collects all data and sends it over communication to the client for execution
 * @extends XhrExecutorInterface
 * @constructor*/
function XhrEngineExecutor(url, callback, method) {
    XhrExecutorInterface.call(this);
    var requestData = {
        url: url,
        method: method,
        headers: {},
        data: null
    };

    var remoteFunction = engine.communication.remote.createRemoteFunctionSource(MESSAGING_DATA.XHR_REMOTE_FUNCTION_SUBJECT);

    function responseHandler(data) {
        var response = new XhrResponse(data);
        callback(response);
        remoteFunction.unregister();
    }

    this.setRequestHeader = function(name, value) {
        requestData.headers[name] = value;
    };

    this.send = function(data) {
        requestData.data = data;
        remoteFunction.callRemote(responseHandler, requestData);
    }
}

/** Decorate XhrExecutor and extends it with additional headers
 * @param {DCMContext} context
 * @param {XhrExecutorInterface} theXhrExecutor to be decorated
 * @extends XhrExecutorInterface
 * @constructor
 */
function XhrExecutorDecorator(context, theXhrExecutor) {
    XhrExecutorInterface.call(this);

    var xhrExecutor = theXhrExecutor;
    var settings = context.storageFactory.getSettings();

    function getValue(valueName) {
        var value = "0";

        if (settings.has(valueName)) {
            value = settings.get(valueName);
        }

        return value;
    }

    function getPiiVersion() {
        if (settings.has(SETTINGS.PII_CONFIG_VERSION)) {
            return settings.get(SETTINGS.PII_CONFIG_VERSION);
        } else {
            return "CPBR001*";
        }
    }

    this.send = function(postData) {
        xhrExecutor.setRequestHeader(SETTINGS.PII_CONFIG_VERSION_HEADER, getPiiVersion());

        xhrExecutor.setRequestHeader(SETTINGS.DCM_CONFIG_VERSION_HEADER,
            getValue(SETTINGS.DCM_CONFIG_VERSION));

        xhrExecutor.send(postData);
    };

    this.setRequestHeader = function(name, value) {
        xhrExecutor.setRequestHeader(name, value);
    };
}


    